<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Libfabric EFA Provider: efa_rdm_pke Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Libfabric EFA Provider
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="structefa__rdm__pke-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">efa_rdm_pke Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Packet entry.  
 <a href="structefa__rdm__pke.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="efa__rdm__pke_8h_source.html">efa_rdm_pke.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5a0e4ea35145e60c3be3e19ed1a9ed41"><td class="memItemLeft" align="right" valign="top">struct dlist_entry&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a5a0e4ea35145e60c3be3e19ed1a9ed41">entry</a></td></tr>
<tr class="separator:a5a0e4ea35145e60c3be3e19ed1a9ed41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79db4d968da191fdf4a16062dee155ac"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structefa__rdm__ep.html">efa_rdm_ep</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a79db4d968da191fdf4a16062dee155ac">ep</a></td></tr>
<tr class="memdesc:a79db4d968da191fdf4a16062dee155ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to <a class="el" href="structefa__rdm__ep.html">efa_rdm_ep</a>  <a href="#a79db4d968da191fdf4a16062dee155ac">More...</a><br/></td></tr>
<tr class="separator:a79db4d968da191fdf4a16062dee155ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd707c6311a4e7c77e31c722599b934"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a5bd707c6311a4e7c77e31c722599b934">ope</a></td></tr>
<tr class="memdesc:a5bd707c6311a4e7c77e31c722599b934"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to <a class="el" href="structefa__rdm__ope.html" title="EFA RDM operation entry (ope) ">efa_rdm_ope</a>  <a href="#a5bd707c6311a4e7c77e31c722599b934">More...</a><br/></td></tr>
<tr class="separator:a5bd707c6311a4e7c77e31c722599b934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d53e9bfb83e1b9697192c7169aba921"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a1d53e9bfb83e1b9697192c7169aba921">pkt_size</a></td></tr>
<tr class="memdesc:a1d53e9bfb83e1b9697192c7169aba921"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of bytes sent/received over wire  <a href="#a1d53e9bfb83e1b9697192c7169aba921">More...</a><br/></td></tr>
<tr class="separator:a1d53e9bfb83e1b9697192c7169aba921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820094896280e83269ed3f82d35fb2ef"><td class="memItemLeft" align="right" valign="top">struct fid_mr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a820094896280e83269ed3f82d35fb2ef">mr</a></td></tr>
<tr class="memdesc:a820094896280e83269ed3f82d35fb2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory registration  <a href="#a820094896280e83269ed3f82d35fb2ef">More...</a><br/></td></tr>
<tr class="separator:a820094896280e83269ed3f82d35fb2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81b8355254adc1553b64dff192e082d"><td class="memItemLeft" align="right" valign="top">fi_addr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#aa81b8355254adc1553b64dff192e082d">addr</a></td></tr>
<tr class="memdesc:aa81b8355254adc1553b64dff192e082d"><td class="mdescLeft">&#160;</td><td class="mdescRight">peer address  <a href="#aa81b8355254adc1553b64dff192e082d">More...</a><br/></td></tr>
<tr class="separator:aa81b8355254adc1553b64dff192e082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0146a97a04d75c8e8d471056107f4b6c"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="efa__rdm__pke_8h.html#a9457b75b4705ca844507d177c3259cbe">efa_rdm_pke_alloc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a0146a97a04d75c8e8d471056107f4b6c">alloc_type</a></td></tr>
<tr class="memdesc:a0146a97a04d75c8e8d471056107f4b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate where the memory of this packet entry reside  <a href="#a0146a97a04d75c8e8d471056107f4b6c">More...</a><br/></td></tr>
<tr class="separator:a0146a97a04d75c8e8d471056107f4b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3aafd2546ca74aa01cb4162460540fe"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#aa3aafd2546ca74aa01cb4162460540fe">flags</a></td></tr>
<tr class="memdesc:aa3aafd2546ca74aa01cb4162460540fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">flags indicating the status of the packet entry  <a href="#aa3aafd2546ca74aa01cb4162460540fe">More...</a><br/></td></tr>
<tr class="separator:aa3aafd2546ca74aa01cb4162460540fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29ee0bb86b4a84cc38a01b3e2805cd0"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#af29ee0bb86b4a84cc38a01b3e2805cd0">next</a></td></tr>
<tr class="memdesc:af29ee0bb86b4a84cc38a01b3e2805cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">link multiple MEDIUM/RUNTREAD RTM with same message ID together  <a href="#af29ee0bb86b4a84cc38a01b3e2805cd0">More...</a><br/></td></tr>
<tr class="separator:af29ee0bb86b4a84cc38a01b3e2805cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafae669281011eafe082a064a07e6522"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#aafae669281011eafe082a064a07e6522">payload</a></td></tr>
<tr class="memdesc:aafae669281011eafe082a064a07e6522"><td class="mdescLeft">&#160;</td><td class="mdescRight">a buffer that contains actual user data that is going over wire  <a href="#aafae669281011eafe082a064a07e6522">More...</a><br/></td></tr>
<tr class="separator:aafae669281011eafe082a064a07e6522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f688cf2c778df46efcf21b70b6ac125"><td class="memItemLeft" align="right" valign="top">struct fid_mr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a5f688cf2c778df46efcf21b70b6ac125">payload_mr</a></td></tr>
<tr class="memdesc:a5f688cf2c778df46efcf21b70b6ac125"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory regstration for user buffer  <a href="#a5f688cf2c778df46efcf21b70b6ac125">More...</a><br/></td></tr>
<tr class="separator:a5f688cf2c778df46efcf21b70b6ac125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bb9e11206cabaf82c5287016c211ea"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a96bb9e11206cabaf82c5287016c211ea">payload_size</a></td></tr>
<tr class="memdesc:a96bb9e11206cabaf82c5287016c211ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of payload buffer  <a href="#a96bb9e11206cabaf82c5287016c211ea">More...</a><br/></td></tr>
<tr class="separator:a96bb9e11206cabaf82c5287016c211ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ed6d3187439d946885b3d45891e246"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a73ed6d3187439d946885b3d45891e246">pad2</a> [32]</td></tr>
<tr class="separator:a73ed6d3187439d946885b3d45891e246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad333ed9dd16b8b07241d4aea71eb0dbb"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#ad333ed9dd16b8b07241d4aea71eb0dbb">wiredata</a> [0]</td></tr>
<tr class="memdesc:ad333ed9dd16b8b07241d4aea71eb0dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer that contains data that is going over wire  <a href="#ad333ed9dd16b8b07241d4aea71eb0dbb">More...</a><br/></td></tr>
<tr class="separator:ad333ed9dd16b8b07241d4aea71eb0dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a861db160af20d2565874ef520b62eb51"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a861db160af20d2565874ef520b62eb51">efa_rdm_pke_alloc</a> (struct <a class="el" href="structefa__rdm__ep.html">efa_rdm_ep</a> *<a class="el" href="structefa__rdm__pke.html#a79db4d968da191fdf4a16062dee155ac">ep</a>, struct ofi_bufpool *pkt_pool, enum <a class="el" href="efa__rdm__pke_8h.html#a9457b75b4705ca844507d177c3259cbe">efa_rdm_pke_alloc_type</a> <a class="el" href="structefa__rdm__pke.html#a0146a97a04d75c8e8d471056107f4b6c">alloc_type</a>)</td></tr>
<tr class="memdesc:a861db160af20d2565874ef520b62eb51"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate a packet entry  <a href="#a861db160af20d2565874ef520b62eb51">More...</a><br/></td></tr>
<tr class="separator:a861db160af20d2565874ef520b62eb51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c7b95eec44787c1d1ca589ed02b65d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#ae6c7b95eec44787c1d1ca589ed02b65d">efa_rdm_pke_release</a> (struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *pke)</td></tr>
<tr class="memdesc:ae6c7b95eec44787c1d1ca589ed02b65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">released packet entry  <a href="#ae6c7b95eec44787c1d1ca589ed02b65d">More...</a><br/></td></tr>
<tr class="separator:ae6c7b95eec44787c1d1ca589ed02b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f22df9ff2a2627552e0c09c7c20887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a25f22df9ff2a2627552e0c09c7c20887">efa_rdm_pke_release_tx</a> (struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *pke)</td></tr>
<tr class="memdesc:a25f22df9ff2a2627552e0c09c7c20887"><td class="mdescLeft">&#160;</td><td class="mdescRight">release a packet entry used by an TX operation  <a href="#a25f22df9ff2a2627552e0c09c7c20887">More...</a><br/></td></tr>
<tr class="separator:a25f22df9ff2a2627552e0c09c7c20887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbda197ba209096b57ae3d6aa2824000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#adbda197ba209096b57ae3d6aa2824000">efa_rdm_pke_release_rx</a> (struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *pke)</td></tr>
<tr class="memdesc:adbda197ba209096b57ae3d6aa2824000"><td class="mdescLeft">&#160;</td><td class="mdescRight">release a packet entry used by a RX operation  <a href="#adbda197ba209096b57ae3d6aa2824000">More...</a><br/></td></tr>
<tr class="separator:adbda197ba209096b57ae3d6aa2824000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ddafa383c96912dc547c230f9cdd72"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#a09ddafa383c96912dc547c230f9cdd72">efa_rdm_pke_clone</a> (struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *src, struct ofi_bufpool *pkt_pool, enum <a class="el" href="efa__rdm__pke_8h.html#a9457b75b4705ca844507d177c3259cbe">efa_rdm_pke_alloc_type</a> <a class="el" href="structefa__rdm__pke.html#a0146a97a04d75c8e8d471056107f4b6c">alloc_type</a>)</td></tr>
<tr class="memdesc:a09ddafa383c96912dc547c230f9cdd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">clone a packet entry  <a href="#a09ddafa383c96912dc547c230f9cdd72">More...</a><br/></td></tr>
<tr class="separator:a09ddafa383c96912dc547c230f9cdd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90d145f66522fd6d1f186009561adf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__pke.html#ac90d145f66522fd6d1f186009561adf5">efa_rdm_pke_fill_data</a> (struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *pke, int pkt_type, struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *<a class="el" href="structefa__rdm__pke.html#a5bd707c6311a4e7c77e31c722599b934">ope</a>, int64_t data_offset, int data_size)</td></tr>
<tr class="memdesc:ac90d145f66522fd6d1f186009561adf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill the a pke with data  <a href="#ac90d145f66522fd6d1f186009561adf5">More...</a><br/></td></tr>
<tr class="separator:ac90d145f66522fd6d1f186009561adf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Packet entry. </p>
<p><a class="el" href="structefa__rdm__pke.html" title="Packet entry. ">efa_rdm_pke</a> (pke stands for packet entry) is used the following occassions:</p>
<p>First, it is used as the work request ID for the request EFA provider posted to EFA device via rdma-core:</p>
<p>For each request EFA provider submits to EFA device, it will allocate a packet entry.</p>
<p>When the request was submitted to rdma-core, the pointer of the packet entry will be used as work request ID (<code>wr_id</code>).</p>
<p>When the request was completed, rdma-core return a completion, with the "wr_id" in it, so EFA provder knows which request has completed.</p>
<p>Sometimes, the completion can be a Receiver Not Ready (RNR) error completion. In that case the packet entry will be queued and resubmitted. For the resubmission, the packet entry must contain all the information of the request.</p>
<p>EFA device (rdma-core) supported request types are: send and receive (by all EFA device) read and write (by certain EFA device)</p>
<p>a send/read/write request uses a packet entry allocated from endpoint's efa_tx_pkt_pool. a read request uses a packet entry allocated from efa_rx_pkt_pool. Both pool's memories are registeredd with efa device, the registration is stored in the "mr" field of the packet entry.</p>
<p>Second, packet entries can be used to store received packet entries that is unexpected or out-of-order. This is because the efa_rx_pkt_pool's size is fixed, therefore it cannot be used to hold unexpected/out-of-order packets. When an unexpected/out-of-order packet is received, a new packet entry will be cloned from unexpected/ooo_pkt_pool. The old packet will be released then reposted to EFA device or SHM. The new packet (allocated from unexpected/ooo_pkt_pool)'s memory is not registered</p>
<p>Finally, packet entries can be used to support local read copy. Local read copy means to copy data from a packet entry to HMEM receive buffer through EFA device's read capability. Local require a packet entry's memory to be registered with device. If the packet entry's memory is not registered (when it is unexpected or out-of-order). A new packet entry will be cloned using endpoint's read_copy_pkt_pool, whose memory was registered. </p>
</div><h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a861db160af20d2565874ef520b62eb51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> * efa_rdm_pke_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ep.html">efa_rdm_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ofi_bufpool *&#160;</td>
          <td class="paramname"><em>pkt_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="efa__rdm__pke_8h.html#a9457b75b4705ca844507d177c3259cbe">efa_rdm_pke_alloc_type</a>&#160;</td>
          <td class="paramname"><em>alloc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocate a packet entry </p>
<p>Allocate a packet entry from given packet packet pool </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ep</td><td>end point </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkt_pool</td><td>packet pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_type</td><td>allocation type see <code>enum efa_rdm_pke_alloc_type</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success return pointer of the allocated packet entry. on failure return NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a09ddafa383c96912dc547c230f9cdd72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> * efa_rdm_pke_clone </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ofi_bufpool *&#160;</td>
          <td class="paramname"><em>pkt_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="efa__rdm__pke_8h.html#a9457b75b4705ca844507d177c3259cbe">efa_rdm_pke_alloc_type</a>&#160;</td>
          <td class="paramname"><em>alloc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clone a packet entry </p>
<p>This function is used on receive side to make a copy of a packet whose memory is on bounce buffer using other buffer pool, so the original packet can be released and posted to device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>packet to be cloned </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkt_pool</td><td>the pool new packet to allocation from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_type</td><td>pool type. Possible values are: EFA_RDM_PKE_FROM_OOO_POOL, EFA_RDM_PKE_FROM_UNEXP_POOL EFA_RDM_PKE_FROM_READCOPY_POOL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to struct <a class="el" href="structefa__rdm__pke.html" title="Packet entry. ">efa_rdm_pke</a>. If packet pool has been exhausted, return NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ac90d145f66522fd6d1f186009561adf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int efa_rdm_pke_fill_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *&#160;</td>
          <td class="paramname"><em>pke</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pkt_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>data_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>fill the a pke with data </p>
<p>This function call the init functions of each packet type to fill a packet with data. Generally, those init functions will:</p>
<ol type="1">
<li>fill "wiredata" with packet header</li>
<li>set the "payload", "payload_size" and "payload_mr" field of a packet entry</li>
<li>set the "pkt_size" field of the packet entry</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pke</td><td>packet entry whose "wiredata" is to be filled </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_type</td><td>packet type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ope</td><td>operation entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_offset</td><td>the data's offset in respect of user's buffer. will be -1 for packet type that does not contain data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>data size carried in this packet. This argument is only available for DATA, MEDIUM_RTM and RUNTREAD_RTM. For all other data types, this argument will be -1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success negative libfabric error code on error </dd></dl>

</div>
</div>
<a class="anchor" id="ae6c7b95eec44787c1d1ca589ed02b65d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_pke_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *&#160;</td>
          <td class="paramname"><em>pke</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>released packet entry </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pke</td><td>packet entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adbda197ba209096b57ae3d6aa2824000"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_pke_release_rx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *&#160;</td>
          <td class="paramname"><em>pke</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release a packet entry used by a RX operation </p>
<p>RX operation include receive/read_response/write_response/atomic_response <a class="el" href="structefa__rdm__pke.html#adbda197ba209096b57ae3d6aa2824000" title="release a packet entry used by a RX operation ">efa_rdm_pke_release_rx()</a> release a rx packet entry. It requires input pke to be unlinked.</p>
<p>RX packet entry can be linked when medium message protocol is used.</p>
<p>In that case, caller is responsible to unlink the pke can call this function on next packet entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pke</td><td>the pke to be released </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25f22df9ff2a2627552e0c09c7c20887"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_pke_release_tx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *&#160;</td>
          <td class="paramname"><em>pke</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release a packet entry used by an TX operation </p>
<p>TX operation include send/read_req/write_req/atomic_req</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pke</td><td>the pke to be released </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aa81b8355254adc1553b64dff192e082d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fi_addr_t efa_rdm_pke::addr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>peer address </p>
<p>When sending a packet, <code>addr</code> will be provided by application and it cannot be FI_ADDR_NOTAVAIL. However, after a packet is sent, application can remove a peer by calling fi_av_remove(). When removing the peering, <code>addr</code> will be set to FI_ADDR_NOTAVAIL. Later, when device report completion for such a TX packet, the TX completion will be ignored.</p>
<p>When receiving a packet, lower device will set <code>addr</code>. If the sender's address is not in address vector (AV), <code>lower device will set</code>addr` to FI_ADDR_NOTAVAIL. This can happen in two scenarios:</p>
<ol type="1">
<li>There has been no prior communication with the peer. In this case, the packet should have peer's raw address in the header, and progress engine will insert the raw address into address vector, and update <code>addr</code>.</li>
<li>This packet is from a peer whose address has been removed from AV. In this case, the recived packet will be ignored because all resources associated with peer has been released. </li>
</ol>

</div>
</div>
<a class="anchor" id="a0146a97a04d75c8e8d471056107f4b6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="efa__rdm__pke_8h.html#a9457b75b4705ca844507d177c3259cbe">efa_rdm_pke_alloc_type</a> efa_rdm_pke::alloc_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indicate where the memory of this packet entry reside </p>

</div>
</div>
<a class="anchor" id="a5a0e4ea35145e60c3be3e19ed1a9ed41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dlist_entry efa_rdm_pke::entry</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>entry to the linked list of outstanding/queued packet entries</p>
<p><code>entry</code> is used for sending only. It is either linked to <code>peer-&gt;outstanding_tx_pkts</code> (after a packet has been successfully sent, but it get a completion), or linked to <code>ope-&gt;queued_pkts</code> (after it encountered RNR error completion). </p>

</div>
</div>
<a class="anchor" id="a79db4d968da191fdf4a16062dee155ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structefa__rdm__ep.html">efa_rdm_ep</a>* efa_rdm_pke::ep</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer to <a class="el" href="structefa__rdm__ep.html">efa_rdm_ep</a> </p>

</div>
</div>
<a class="anchor" id="aa3aafd2546ca74aa01cb4162460540fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t efa_rdm_pke::flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flags indicating the status of the packet entry </p>
<p>Possible flags include <a class="el" href="efa__rdm__pke_8h.html#ab7736f7fa320da45cc1cee1d07e644a7">EFA_RDM_PKE_IN_USE</a> <a class="el" href="efa__rdm__pke_8h.html#afe02fcd778bc4507d127257fedf74f61">EFA_RDM_PKE_RNR_RETRANSMIT</a>, <a class="el" href="efa__rdm__pke_8h.html#aadf44df5c24ecec0b55b83b2045f2224">EFA_RDM_PKE_LOCAL_READ</a>, and <a class="el" href="efa__rdm__pke_8h.html#a067c4db40adb6fcf1f641f937342fa1b">EFA_RDM_PKE_DC_LONGCTS_DATA</a> </p>

</div>
</div>
<a class="anchor" id="a820094896280e83269ed3f82d35fb2ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fid_mr* efa_rdm_pke::mr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>memory registration </p>
<p>If this packet is used by EFA device, <code>mr</code> the memory registration of wiredata over the EFA device. If this packet is used by SHM, <code>mr</code> is NULL because SHM does not require memory registration</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Use type <code>struct ibv_mr</code> instead of <code>struct fid_mr</code> for this field </dd></dl>

</div>
</div>
<a class="anchor" id="af29ee0bb86b4a84cc38a01b3e2805cd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a>* efa_rdm_pke::next</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>link multiple MEDIUM/RUNTREAD RTM with same message ID together </p>
<p>used on receiver side only </p>

</div>
</div>
<a class="anchor" id="a5bd707c6311a4e7c77e31c722599b934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a>* efa_rdm_pke::ope</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer to <a class="el" href="structefa__rdm__ope.html" title="EFA RDM operation entry (ope) ">efa_rdm_ope</a> </p>

</div>
</div>
<a class="anchor" id="a73ed6d3187439d946885b3d45891e246"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t efa_rdm_pke::pad2[32]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aafae669281011eafe082a064a07e6522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* efa_rdm_pke::payload</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a buffer that contains actual user data that is going over wire </p>
<p>"payload" points to either a location inside user's buffer, (when user's buffer is registered with EFA device), or a location in "wiredata" (where user data has been copied to). The EFA provider tries its best to avoid copy, but copy is not always avoidable. </p>

</div>
</div>
<a class="anchor" id="a5f688cf2c778df46efcf21b70b6ac125"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fid_mr* efa_rdm_pke::payload_mr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>memory regstration for user buffer </p>
<p>payload_mr is same as mr, when payload is pointing to a location inside wiredata. </p>

</div>
</div>
<a class="anchor" id="a96bb9e11206cabaf82c5287016c211ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t efa_rdm_pke::payload_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>size of payload buffer </p>

</div>
</div>
<a class="anchor" id="a1d53e9bfb83e1b9697192c7169aba921"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t efa_rdm_pke::pkt_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of bytes sent/received over wire </p>

</div>
</div>
<a class="anchor" id="ad333ed9dd16b8b07241d4aea71eb0dbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char efa_rdm_pke::wiredata[0]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buffer that contains data that is going over wire </p>
<p>wiredata consists of 3 parts:</p>
<ol type="1">
<li>Packet header. All packet entries have a packet header, except the packet entry allocated from readcopy_pool.</li>
<li>User buffer infomation, which presents only for LONGREAD and RUNTREAD RTM packets.</li>
<li>User data, which presents when: a) pakcet is an outging (TX) packet, and EFA device is not able to send data directory from user's buffer (thus data has been copied to wiredata). b) packet is an incoming (RX) packet. </li>
</ol>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>prov/efa/src/rdm/<a class="el" href="efa__rdm__pke_8h_source.html">efa_rdm_pke.h</a></li>
<li>prov/efa/src/rdm/<a class="el" href="efa__rdm__pke_8c.html">efa_rdm_pke.c</a></li>
<li>prov/efa/src/rdm/<a class="el" href="efa__rdm__pke__cmd_8c.html">efa_rdm_pke_cmd.c</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
