<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Libfabric EFA Provider: rxr_pkt_entry Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Libfabric EFA Provider
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="structrxr__pkt__entry-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">rxr_pkt_entry Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Packet entry.  
 <a href="structrxr__pkt__entry.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rxr__pkt__entry_8h_source.html">rxr_pkt_entry.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:add406809dcb982ddc9f69ca0a49bd6e1"><td class="memItemLeft" align="right" valign="top">struct dlist_entry&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#add406809dcb982ddc9f69ca0a49bd6e1">entry</a></td></tr>
<tr class="separator:add406809dcb982ddc9f69ca0a49bd6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae026c3ad792306e45c49b8e6bbca8ab9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#ae026c3ad792306e45c49b8e6bbca8ab9">x_entry</a></td></tr>
<tr class="memdesc:ae026c3ad792306e45c49b8e6bbca8ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> or <a class="el" href="structrxr__read__entry.html">rxr_read_entry</a>  <a href="structrxr__pkt__entry.html#ae026c3ad792306e45c49b8e6bbca8ab9">More...</a><br /></td></tr>
<tr class="separator:ae026c3ad792306e45c49b8e6bbca8ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269859dd966decb98fc837f56fa22363"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#a269859dd966decb98fc837f56fa22363">pkt_size</a></td></tr>
<tr class="memdesc:a269859dd966decb98fc837f56fa22363"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of bytes sent/received over wire  <a href="structrxr__pkt__entry.html#a269859dd966decb98fc837f56fa22363">More...</a><br /></td></tr>
<tr class="separator:a269859dd966decb98fc837f56fa22363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087489fc89b66394039db955fed09db3"><td class="memItemLeft" align="right" valign="top">struct fid_mr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#a087489fc89b66394039db955fed09db3">mr</a></td></tr>
<tr class="memdesc:a087489fc89b66394039db955fed09db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory registration  <a href="structrxr__pkt__entry.html#a087489fc89b66394039db955fed09db3">More...</a><br /></td></tr>
<tr class="separator:a087489fc89b66394039db955fed09db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450e5ec6a0518551f62b1a4e247aeb34"><td class="memItemLeft" align="right" valign="top">fi_addr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#a450e5ec6a0518551f62b1a4e247aeb34">addr</a></td></tr>
<tr class="memdesc:a450e5ec6a0518551f62b1a4e247aeb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">peer address  <a href="structrxr__pkt__entry.html#a450e5ec6a0518551f62b1a4e247aeb34">More...</a><br /></td></tr>
<tr class="separator:a450e5ec6a0518551f62b1a4e247aeb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653ea9c9b8f5ef65e3bd2c88428a295e"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="rxr__pkt__entry_8h.html#a5bfee5499517616bc20acfaaaa58846f">rxr_pkt_entry_alloc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#a653ea9c9b8f5ef65e3bd2c88428a295e">alloc_type</a></td></tr>
<tr class="memdesc:a653ea9c9b8f5ef65e3bd2c88428a295e"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate where the memory of this packet entry reside  <a href="structrxr__pkt__entry.html#a653ea9c9b8f5ef65e3bd2c88428a295e">More...</a><br /></td></tr>
<tr class="separator:a653ea9c9b8f5ef65e3bd2c88428a295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba837b763801bee7739572bd8711ae8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#a0ba837b763801bee7739572bd8711ae8">flags</a></td></tr>
<tr class="memdesc:a0ba837b763801bee7739572bd8711ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">flags indicating the status of the packet entry  <a href="structrxr__pkt__entry.html#a0ba837b763801bee7739572bd8711ae8">More...</a><br /></td></tr>
<tr class="separator:a0ba837b763801bee7739572bd8711ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c24e463479252740d37f72640dd5fc2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#a3c24e463479252740d37f72640dd5fc2">next</a></td></tr>
<tr class="memdesc:a3c24e463479252740d37f72640dd5fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">link multiple MEDIUM RTM with same message ID together  <a href="structrxr__pkt__entry.html#a3c24e463479252740d37f72640dd5fc2">More...</a><br /></td></tr>
<tr class="separator:a3c24e463479252740d37f72640dd5fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eae6213ab45c0c0ff38b9b09e6a73e3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxr__pkt__sendv.html">rxr_pkt_sendv</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#a4eae6213ab45c0c0ff38b9b09e6a73e3">send</a></td></tr>
<tr class="memdesc:a4eae6213ab45c0c0ff38b9b09e6a73e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">information of send buffer  <a href="structrxr__pkt__entry.html#a4eae6213ab45c0c0ff38b9b09e6a73e3">More...</a><br /></td></tr>
<tr class="separator:a4eae6213ab45c0c0ff38b9b09e6a73e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec332ed480667d538150368c5c2a7352"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#aec332ed480667d538150368c5c2a7352">wiredata</a></td></tr>
<tr class="memdesc:aec332ed480667d538150368c5c2a7352"><td class="mdescLeft">&#160;</td><td class="mdescRight">buffer that contains data that is going over wire  <a href="structrxr__pkt__entry.html#aec332ed480667d538150368c5c2a7352">More...</a><br /></td></tr>
<tr class="separator:aec332ed480667d538150368c5c2a7352"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ab137b239d93a9e15736b0b6c4eaf9f3e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#ab137b239d93a9e15736b0b6c4eaf9f3e">rxr_pkt_entry_alloc</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__pool.html">rxr_pkt_pool</a> *pkt_pool, enum <a class="el" href="rxr__pkt__entry_8h.html#a5bfee5499517616bc20acfaaaa58846f">rxr_pkt_entry_alloc_type</a> <a class="el" href="structrxr__pkt__entry.html#a653ea9c9b8f5ef65e3bd2c88428a295e">alloc_type</a>)</td></tr>
<tr class="memdesc:ab137b239d93a9e15736b0b6c4eaf9f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate a packet entry  <a href="structrxr__pkt__entry.html#ab137b239d93a9e15736b0b6c4eaf9f3e">More...</a><br /></td></tr>
<tr class="separator:ab137b239d93a9e15736b0b6c4eaf9f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4facfca19274431b9926f9155001d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#af4facfca19274431b9926f9155001d83">rxr_pkt_entry_release</a> (struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry)</td></tr>
<tr class="memdesc:af4facfca19274431b9926f9155001d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">released packet entry  <a href="structrxr__pkt__entry.html#af4facfca19274431b9926f9155001d83">More...</a><br /></td></tr>
<tr class="separator:af4facfca19274431b9926f9155001d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01a52bb874934e10bf924e339351c17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#ae01a52bb874934e10bf924e339351c17">rxr_pkt_entry_release_tx</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry)</td></tr>
<tr class="memdesc:ae01a52bb874934e10bf924e339351c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">release a packet entry used by an TX operation  <a href="structrxr__pkt__entry.html#ae01a52bb874934e10bf924e339351c17">More...</a><br /></td></tr>
<tr class="separator:ae01a52bb874934e10bf924e339351c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be10d05cd99b49948b3befaf5e87e35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#a7be10d05cd99b49948b3befaf5e87e35">rxr_pkt_entry_release_rx</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry)</td></tr>
<tr class="memdesc:a7be10d05cd99b49948b3befaf5e87e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">release a packet entry used by a RX operation  <a href="structrxr__pkt__entry.html#a7be10d05cd99b49948b3befaf5e87e35">More...</a><br /></td></tr>
<tr class="separator:a7be10d05cd99b49948b3befaf5e87e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b646e38f2114e503283730cccad512"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrxr__pkt__entry.html#a18b646e38f2114e503283730cccad512">rxr_pkt_entry_clone</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__pool.html">rxr_pkt_pool</a> *pkt_pool, enum <a class="el" href="rxr__pkt__entry_8h.html#a5bfee5499517616bc20acfaaaa58846f">rxr_pkt_entry_alloc_type</a> <a class="el" href="structrxr__pkt__entry.html#a653ea9c9b8f5ef65e3bd2c88428a295e">alloc_type</a>, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *src)</td></tr>
<tr class="memdesc:a18b646e38f2114e503283730cccad512"><td class="mdescLeft">&#160;</td><td class="mdescRight">clone a packet entry  <a href="structrxr__pkt__entry.html#a18b646e38f2114e503283730cccad512">More...</a><br /></td></tr>
<tr class="separator:a18b646e38f2114e503283730cccad512"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Packet entry. </p>
<p ><a class="el" href="structrxr__pkt__entry.html" title="Packet entry.">rxr_pkt_entry</a> is used the following occassions:</p>
<p >First, it is used as the context of the request EFA provider posted to EFA device and SHM:</p>
<p >For each request EFA provider submits to (EFA device or SHM), it will allocate a packet entry.</p>
<p >When the request was submitted, the pointer of the packet entry will be used as context. For EFA device, context is work request ID (<code>wr_id</code>), For SHM, context is the <code>op_context</code> in a <code>fi_msg</code>.</p>
<p >When the request was completed, EFA device or SHM will return a completion entry, with the the pointer to the <a class="el" href="structrxr__pkt__entry.html" title="Packet entry.">rxr_pkt_entry</a> in it.</p>
<p >In a specail occasion, he completion can be a Receiver Not Ready (RNR) error completion. In that case the packet entry will be queued and resubmitted. For the resubmission, Therefore it must contain all the information of the request.</p>
<p >An operation can be either a TX operation or a receive (RX) operation</p>
<p >For EFA device, a TX operation can be send/read.</p>
<p >For SHM, a TX operation can be send/read/write/atomic.</p>
<p >When used as context of request, packet was allocated from endpoint's shm/efa_tx/rx_pool. When the request is to EFA device, the packet's memory must be registered to EFA device, and the memory registration must be stored as the <code>mr</code> field of packet entry.</p>
<p >Second, packet entries can be used o store received packet entries that is unexpected or out-of-order. This is because the efa/shm_rx_pkt_pool's size is fixed, therefore cannot be used to hold unexpected/out-of-order packets. When an unexpected/out-of-order packet is received, a new packet entry will be cloned from unexpected/ooo_pkt_pool. The old packet will be released then reposted to device. The new packet's memory is not registered</p>
<p >Finally, packet entries can be used to support local read copy. Local read copy means to copy data from a packet entry to HMEM receive buffer through EFA device's read capability. Local require a packet entry's memory to be registered with device. If the packet entry's memory is not registered (when it is unexpected or out-of-order). A new packet entry will be cloned using endpoint's read_copy_pkt_pool, whose memory was registered. </p>
</div><h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab137b239d93a9e15736b0b6c4eaf9f3e" name="ab137b239d93a9e15736b0b6c4eaf9f3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab137b239d93a9e15736b0b6c4eaf9f3e">&#9670;&#160;</a></span>rxr_pkt_entry_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> * rxr_pkt_entry_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__pool.html">rxr_pkt_pool</a> *&#160;</td>
          <td class="paramname"><em>pkt_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rxr__pkt__entry_8h.html#a5bfee5499517616bc20acfaaaa58846f">rxr_pkt_entry_alloc_type</a>&#160;</td>
          <td class="paramname"><em>alloc_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>allocate a packet entry </p>
<p >Allocate a packet entry from given packet packet pool </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ep</td><td>end point </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkt_pool</td><td>packet pool </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alloc_type</td><td>allocation type see <code>enum rxr_pkt_entry_alloc_type</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success return pointer of the allocated packet entry. on failure return NULL </dd></dl>

</div>
</div>
<a id="a18b646e38f2114e503283730cccad512" name="a18b646e38f2114e503283730cccad512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b646e38f2114e503283730cccad512">&#9670;&#160;</a></span>rxr_pkt_entry_clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> * rxr_pkt_entry_clone </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__pool.html">rxr_pkt_pool</a> *&#160;</td>
          <td class="paramname"><em>pkt_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rxr__pkt__entry_8h.html#a5bfee5499517616bc20acfaaaa58846f">rxr_pkt_entry_alloc_type</a>&#160;</td>
          <td class="paramname"><em>alloc_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clone a packet entry </p>
<p >This function is used on receive side to make a copy of a packet whose memory is on bounce buffer using other buffer pool, so the original packet can be released and posted to device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td></td></tr>
    <tr><td class="paramname">pkt_pool</td><td></td></tr>
    <tr><td class="paramname">alloc_type</td><td></td></tr>
    <tr><td class="paramname">src</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>struct rxr_pkt_entry* </dd></dl>

</div>
</div>
<a id="af4facfca19274431b9926f9155001d83" name="af4facfca19274431b9926f9155001d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4facfca19274431b9926f9155001d83">&#9670;&#160;</a></span>rxr_pkt_entry_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_pkt_entry_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>released packet entry </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_entry</td><td>packet entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7be10d05cd99b49948b3befaf5e87e35" name="a7be10d05cd99b49948b3befaf5e87e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be10d05cd99b49948b3befaf5e87e35">&#9670;&#160;</a></span>rxr_pkt_entry_release_rx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_pkt_entry_release_rx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release a packet entry used by a RX operation </p>
<p >RX operation include receive/read_response/write_response/atomic_response <a class="el" href="structrxr__pkt__entry.html#a7be10d05cd99b49948b3befaf5e87e35" title="release a packet entry used by a RX operation">rxr_pkt_entry_release_rx()</a> release a rx packet entry. It requires input pkt_entry to be unlinked.</p>
<p >RX packet entry can be linked when medium message protocol is used.</p>
<p >In that case, caller is responsible to unlink the pkt_entry can call this function on next packet entry. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>the end point </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkt_entry</td><td>the pkt_entry to be released </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae01a52bb874934e10bf924e339351c17" name="ae01a52bb874934e10bf924e339351c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01a52bb874934e10bf924e339351c17">&#9670;&#160;</a></span>rxr_pkt_entry_release_tx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_pkt_entry_release_tx </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>release a packet entry used by an TX operation </p>
<p >TX operation include send/read_req/write_req/atomic_req</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>the end point </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkt_entry</td><td>the pkt_entry to be released </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a450e5ec6a0518551f62b1a4e247aeb34" name="a450e5ec6a0518551f62b1a4e247aeb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450e5ec6a0518551f62b1a4e247aeb34">&#9670;&#160;</a></span>addr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fi_addr_t rxr_pkt_entry::addr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>peer address </p>
<p >When sending a packet, <code>addr</code> will be provided by application and it cannot be FI_ADDR_NOTAVAIL. However, after a packet is sent, application can remove a peer by calling fi_av_remove(). When removing the peering, <code>addr</code> will be set to FI_ADDR_NOTAVAIL. Later, when device report completion for such a TX packet, the TX completion will be ignored.</p>
<p >When receiving a packet, lower device will set <code>addr</code>. If the sender's address is not in address vector (AV), <code>lower device will set</code>addr` to FI_ADDR_NOTAVAIL. This can happen in two scenarios:</p>
<ol type="1">
<li>There has been no prior communication with the peer. In this case, the packet should have peer's raw address in the header, and progress engine will insert the raw address into address vector, and update <code>addr</code>.</li>
<li>This packet is from a peer whose address has been removed from AV. In this case, the recived packet will be ignored because all resources associated with peer has been released. </li>
</ol>

</div>
</div>
<a id="a653ea9c9b8f5ef65e3bd2c88428a295e" name="a653ea9c9b8f5ef65e3bd2c88428a295e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653ea9c9b8f5ef65e3bd2c88428a295e">&#9670;&#160;</a></span>alloc_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rxr__pkt__entry_8h.html#a5bfee5499517616bc20acfaaaa58846f">rxr_pkt_entry_alloc_type</a> rxr_pkt_entry::alloc_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indicate where the memory of this packet entry reside </p>

</div>
</div>
<a id="add406809dcb982ddc9f69ca0a49bd6e1" name="add406809dcb982ddc9f69ca0a49bd6e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add406809dcb982ddc9f69ca0a49bd6e1">&#9670;&#160;</a></span>entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dlist_entry rxr_pkt_entry::entry</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >entry to the linked list of outstanding/queued packet entries</p>
<p ><code>entry</code> is used for sending only. It is either linked to <code>peer-&gt;outstanding_tx_pkts</code> (after a packet has been successfully sent, but it get a completion), or linked to <code>op_entry-&gt;queued_pkts</code> (after it encountered RNR error completion). </p>

</div>
</div>
<a id="a0ba837b763801bee7739572bd8711ae8" name="a0ba837b763801bee7739572bd8711ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba837b763801bee7739572bd8711ae8">&#9670;&#160;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rxr_pkt_entry::flags</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flags indicating the status of the packet entry </p>
<p >Possisle flags include <a class="el" href="rxr__pkt__entry_8h.html#a18d01561c6abb920fe65e93756aa7b71">RXR_PKT_ENTRY_IN_USE</a> <a class="el" href="rxr__pkt__entry_8h.html#a0914124572ca34f05dfd42c84383945e">RXR_PKT_ENTRY_RNR_RETRANSMIT</a> and <a class="el" href="rxr__pkt__entry_8h.html#a4354880df2e225592b242ecc160d9e13">RXR_PKT_ENTRY_LOCAL_READ</a> </p>

</div>
</div>
<a id="a087489fc89b66394039db955fed09db3" name="a087489fc89b66394039db955fed09db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087489fc89b66394039db955fed09db3">&#9670;&#160;</a></span>mr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fid_mr* rxr_pkt_entry::mr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>memory registration </p>
<p >If this packet is used by EFA device, <code>mr</code> the memory registration of wiredata over the EFA device. If this packet is used by SHM, <code>mr</code> is NULL because SHM does not require memory registration</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Use type <code>struct ibv_mr</code> instead of <code>struct fid_mr</code> for this field </dd></dl>

</div>
</div>
<a id="a3c24e463479252740d37f72640dd5fc2" name="a3c24e463479252740d37f72640dd5fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c24e463479252740d37f72640dd5fc2">&#9670;&#160;</a></span>next</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a>* rxr_pkt_entry::next</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>link multiple MEDIUM RTM with same message ID together </p>
<p >used on receiver side only </p>

</div>
</div>
<a id="a269859dd966decb98fc837f56fa22363" name="a269859dd966decb98fc837f56fa22363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269859dd966decb98fc837f56fa22363">&#9670;&#160;</a></span>pkt_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t rxr_pkt_entry::pkt_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of bytes sent/received over wire </p>

</div>
</div>
<a id="a4eae6213ab45c0c0ff38b9b09e6a73e3" name="a4eae6213ab45c0c0ff38b9b09e6a73e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eae6213ab45c0c0ff38b9b09e6a73e3">&#9670;&#160;</a></span>send</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxr__pkt__sendv.html">rxr_pkt_sendv</a> rxr_pkt_entry::send</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>information of send buffer </p>

</div>
</div>
<a id="aec332ed480667d538150368c5c2a7352" name="aec332ed480667d538150368c5c2a7352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec332ed480667d538150368c5c2a7352">&#9670;&#160;</a></span>wiredata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* rxr_pkt_entry::wiredata</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>buffer that contains data that is going over wire </p>

</div>
</div>
<a id="ae026c3ad792306e45c49b8e6bbca8ab9" name="ae026c3ad792306e45c49b8e6bbca8ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae026c3ad792306e45c49b8e6bbca8ab9">&#9670;&#160;</a></span>x_entry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* rxr_pkt_entry::x_entry</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pointer to <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> or <a class="el" href="structrxr__read__entry.html">rxr_read_entry</a> </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>prov/efa/src/rxr/<a class="el" href="rxr__pkt__entry_8h_source.html">rxr_pkt_entry.h</a></li>
<li>prov/efa/src/rxr/<a class="el" href="rxr__pkt__entry_8c.html">rxr_pkt_entry.c</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
