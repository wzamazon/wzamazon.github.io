<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Libfabric EFA Provider: prov/efa/src/rxr/rxr_pkt_type_base.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Libfabric EFA Provider
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d46679ce1435edc13ddade6ebade25f4.html">prov</a></li><li class="navelem"><a class="el" href="dir_d7cf6fdb83f41a3999019906e7af8b56.html">efa</a></li><li class="navelem"><a class="el" href="dir_b78761dad90496b57e16a2b87cb4161d.html">src</a></li><li class="navelem"><a class="el" href="dir_5e6ba55d6661b4254686e3fa900dc191.html">rxr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">rxr_pkt_type_base.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="rxr_8h_source.html">rxr.h</a>&quot;</code><br />
</div>
<p><a href="rxr__pkt__type__base_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abf0c9927fb4fd1c99c9774f521f471d0"><td class="memItemLeft" align="right" valign="top">uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__type__base_8h.html#abf0c9927fb4fd1c99c9774f521f471d0">rxr_pkt_connid_ptr</a> (struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry)</td></tr>
<tr class="memdesc:abf0c9927fb4fd1c99c9774f521f471d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the optional connid header pointer in a packet  <a href="rxr__pkt__type__base_8h.html#abf0c9927fb4fd1c99c9774f521f471d0">More...</a><br /></td></tr>
<tr class="separator:abf0c9927fb4fd1c99c9774f521f471d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e42a85cbd5522b1d1ae6b9492729a08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__type__base_8h.html#a0e42a85cbd5522b1d1ae6b9492729a08">rxr_pkt_init_data_from_op_entry</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry, size_t pkt_data_offset, struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *op_entry, size_t op_data_offset, size_t data_size)</td></tr>
<tr class="memdesc:a0e42a85cbd5522b1d1ae6b9492729a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">set up data in a packet entry using tx_entry/rx_entry information, such that the packet is ready to be sent. Depending on the op_entry, this function can either copy data to packet entry, or point pkt_entry-&gt;iov to op_entry-&gt;iov. It requires the packet header to be set.  <a href="rxr__pkt__type__base_8h.html#a0e42a85cbd5522b1d1ae6b9492729a08">More...</a><br /></td></tr>
<tr class="separator:a0e42a85cbd5522b1d1ae6b9492729a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93de7306c7b88fe4dd09a6a74e9f510b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__type__base_8h.html#a93de7306c7b88fe4dd09a6a74e9f510b">rxr_pkt_copy_data_to_op_entry</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *rx_entry, size_t data_offset, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry, char *data, size_t data_size)</td></tr>
<tr class="memdesc:a93de7306c7b88fe4dd09a6a74e9f510b"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy data to application's receive buffer and update counter in rx_entry.  <a href="rxr__pkt__type__base_8h.html#a93de7306c7b88fe4dd09a6a74e9f510b">More...</a><br /></td></tr>
<tr class="separator:a93de7306c7b88fe4dd09a6a74e9f510b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798d0dd9a62ca5711711b440c9badf1e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__type__base_8h.html#a798d0dd9a62ca5711711b440c9badf1e">rxr_pkt_data_size</a> (struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry)</td></tr>
<tr class="separator:a798d0dd9a62ca5711711b440c9badf1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="abf0c9927fb4fd1c99c9774f521f471d0" name="abf0c9927fb4fd1c99c9774f521f471d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0c9927fb4fd1c99c9774f521f471d0">&#9670;&#160;</a></span>rxr_pkt_connid_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t * rxr_pkt_connid_ptr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the optional connid header pointer in a packet </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_entry</td><td>an packet entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the input has the optional connid header, return the pointer to connid header Otherwise, return NULL </dd></dl>

</div>
</div>
<a id="a93de7306c7b88fe4dd09a6a74e9f510b" name="a93de7306c7b88fe4dd09a6a74e9f510b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93de7306c7b88fe4dd09a6a74e9f510b">&#9670;&#160;</a></span>rxr_pkt_copy_data_to_op_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rxr_pkt_copy_data_to_op_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *&#160;</td>
          <td class="paramname"><em>op_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy data to application's receive buffer and update counter in rx_entry. </p>
<p >Depend on when application's receive buffer is located (host or device) and the software stack, this function will select different, strategies to copy data.</p>
<p >When application's receive buffer is on device, there are two scenarios:</p>
<p >If memory is on cuda GPU, and gdrcopy is not available, this function will post a local read request to copy data. (This is because NCCL forbids its plugin to make cuda calls). In this case, the data is not copied upon return of this function, and the function rxr_pkt_handle_copied() is not called. It will be called upon the completion of local read operation by the progress engine.</p>
<p >Otherwise, this function calls rxr_pkt_copy_data_to_hmem(), which will batch multiple copies, and perform the copy (then call rxr_pkt_handle_copied()) together to improve performance.</p>
<p >When application's receive buffer is on host, data is copied immediately, and rxr_pkt_handle_copied() is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">op_entry</td><td>op_entry contains information of the receive op. This function uses receive buffer in it. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_offset</td><td>data offset in the packet in the receiving buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_entry</td><td>the packet entry that contains data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the pointer pointing to the beginning of data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>the length of data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, return 0 On failure, return libfabric error code </dd></dl>

</div>
</div>
<a id="a798d0dd9a62ca5711711b440c9badf1e" name="a798d0dd9a62ca5711711b440c9badf1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798d0dd9a62ca5711711b440c9badf1e">&#9670;&#160;</a></span>rxr_pkt_data_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t rxr_pkt_data_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e42a85cbd5522b1d1ae6b9492729a08" name="a0e42a85cbd5522b1d1ae6b9492729a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e42a85cbd5522b1d1ae6b9492729a08">&#9670;&#160;</a></span>rxr_pkt_init_data_from_op_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rxr_pkt_init_data_from_op_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pkt_data_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *&#160;</td>
          <td class="paramname"><em>op_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tx_data_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set up data in a packet entry using tx_entry/rx_entry information, such that the packet is ready to be sent. Depending on the op_entry, this function can either copy data to packet entry, or point pkt_entry-&gt;iov to op_entry-&gt;iov. It requires the packet header to be set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>end point. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pkt_entry</td><td>packet entry. Header must have been set when the function is called </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_data_offset</td><td>the data offset in packet, (in reference to pkt_entry-&gt;wiredata). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_entry</td><td>This function will use iov, iov_count and desc of op_entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_data_offset</td><td>source offset of the data (in reference to op_entry-&gt;iov) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>length of the data to be set up. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative FI code on error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
