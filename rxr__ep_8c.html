<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Libfabric EFA Provider: prov/efa/src/rxr/rxr_ep.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Libfabric EFA Provider
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d46679ce1435edc13ddade6ebade25f4.html">prov</a></li><li class="navelem"><a class="el" href="dir_d7cf6fdb83f41a3999019906e7af8b56.html">efa</a></li><li class="navelem"><a class="el" href="dir_b78761dad90496b57e16a2b87cb4161d.html">src</a></li><li class="navelem"><a class="el" href="dir_5e6ba55d6661b4254686e3fa900dc191.html">rxr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">rxr_ep.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;ofi.h&quot;</code><br />
<code>#include &lt;ofi_util.h&gt;</code><br />
<code>#include &lt;ofi_iov.h&gt;</code><br />
<code>#include &quot;<a class="el" href="efa_8h_source.html">efa.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="efa__cq_8h_source.html">efa_cq.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rxr__msg_8h_source.html">rxr_msg.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rxr__rma_8h_source.html">rxr_rma.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rxr__pkt__cmd_8h_source.html">rxr_pkt_cmd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rxr__pkt__type__base_8h_source.html">rxr_pkt_type_base.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rxr__read_8h_source.html">rxr_read.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rxr__atomic_8h_source.html">rxr_atomic.h</a>&quot;</code><br />
<code>#include &lt;infiniband/verbs.h&gt;</code><br />
<code>#include &quot;<a class="el" href="rxr__tp_8h_source.html">rxr_tp.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab6d07476c1eec64a8c1c9bb80f0c47a2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structefa__ep__addr.html">efa_ep_addr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#ab6d07476c1eec64a8c1c9bb80f0c47a2">rxr_ep_raw_addr</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep)</td></tr>
<tr class="separator:ab6d07476c1eec64a8c1c9bb80f0c47a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3436edef34b25360d62a6668532fbe43"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#a3436edef34b25360d62a6668532fbe43">rxr_ep_raw_addr_str</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, char *buf, size_t *buflen)</td></tr>
<tr class="separator:a3436edef34b25360d62a6668532fbe43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338ba2f3ae4f3af39b7ca5550cb6f25b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structefa__ep__addr.html">efa_ep_addr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#a338ba2f3ae4f3af39b7ca5550cb6f25b">rxr_peer_raw_addr</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, fi_addr_t addr)</td></tr>
<tr class="separator:a338ba2f3ae4f3af39b7ca5550cb6f25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45efbb4791011739590a6bea6731d9f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#ad45efbb4791011739590a6bea6731d9f">rxr_peer_raw_addr_str</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, fi_addr_t addr, char *buf, size_t *buflen)</td></tr>
<tr class="separator:ad45efbb4791011739590a6bea6731d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55357c5aa066f0e245aa6ba65ac0aab6"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#a55357c5aa066f0e245aa6ba65ac0aab6">rxr_ep_alloc_rx_entry</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, fi_addr_t addr, uint32_t op)</td></tr>
<tr class="memdesc:a55357c5aa066f0e245aa6ba65ac0aab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocate an rx entry for an operation  <a href="rxr__ep_8c.html#a55357c5aa066f0e245aa6ba65ac0aab6">More...</a><br /></td></tr>
<tr class="separator:a55357c5aa066f0e245aa6ba65ac0aab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496fc2f47ea12949902f83bf0051c5f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#a496fc2f47ea12949902f83bf0051c5f7">rxr_ep_post_user_recv_buf</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *rx_entry, uint64_t flags)</td></tr>
<tr class="memdesc:a496fc2f47ea12949902f83bf0051c5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">post user provided receiving buffer to the device.  <a href="rxr__ep_8c.html#a496fc2f47ea12949902f83bf0051c5f7">More...</a><br /></td></tr>
<tr class="separator:a496fc2f47ea12949902f83bf0051c5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51f27a322b72f2d177b7a19af596fcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#aa51f27a322b72f2d177b7a19af596fcb">rxr_ep_post_internal_rx_pkt</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, uint64_t flags, enum <a class="el" href="rxr_8h.html#a980c99793a2be650d15fdadba2b49fdb">rxr_lower_ep_type</a> lower_ep_type)</td></tr>
<tr class="memdesc:aa51f27a322b72f2d177b7a19af596fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">post an internal receive buffer to lower endpoint  <a href="rxr__ep_8c.html#aa51f27a322b72f2d177b7a19af596fcb">More...</a><br /></td></tr>
<tr class="separator:aa51f27a322b72f2d177b7a19af596fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34444e71608340ae389f977191fac2b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#a34444e71608340ae389f977191fac2b8">rxr_tx_entry_init</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *tx_entry, const struct fi_msg *msg, uint32_t op, uint64_t flags)</td></tr>
<tr class="separator:a34444e71608340ae389f977191fac2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18bc1a94a40cd37af3d3700e55040b3"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#ae18bc1a94a40cd37af3d3700e55040b3">rxr_ep_alloc_tx_entry</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *<a class="el" href="structrxr__ep.html">rxr_ep</a>, const struct fi_msg *msg, uint32_t op, uint64_t tag, uint64_t flags)</td></tr>
<tr class="separator:ae18bc1a94a40cd37af3d3700e55040b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736977c53d826fdea255b8ac76ffe0d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#a736977c53d826fdea255b8ac76ffe0d3">rxr_release_tx_entry</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *tx_entry)</td></tr>
<tr class="separator:a736977c53d826fdea255b8ac76ffe0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5f563dce1fe324483a2c05e95c1d6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#afc5f563dce1fe324483a2c05e95c1d6e">rxr_convert_desc_for_shm</a> (int numdesc, void **desc)</td></tr>
<tr class="memdesc:afc5f563dce1fe324483a2c05e95c1d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert EFA descriptors to shm descriptors.  <a href="rxr__ep_8c.html#afc5f563dce1fe324483a2c05e95c1d6e">More...</a><br /></td></tr>
<tr class="separator:afc5f563dce1fe324483a2c05e95c1d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b4bdf8f4f8f126260739b4703af20f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#ab2b4bdf8f4f8f126260739b4703af20f">rxr_prepare_desc_send</a> (struct <a class="el" href="structefa__domain.html">efa_domain</a> *<a class="el" href="structefa__domain.html">efa_domain</a>, struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *tx_entry)</td></tr>
<tr class="separator:ab2b4bdf8f4f8f126260739b4703af20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee308149826f9e3869b4ecb3a4293a1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#aee308149826f9e3869b4ecb3a4293a1c">rxr_ep_determine_rdma_support</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, fi_addr_t addr, struct <a class="el" href="structrdm__peer.html">rdm_peer</a> *peer)</td></tr>
<tr class="separator:aee308149826f9e3869b4ecb3a4293a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7748ca9bf9b592cbdc94707761495d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#aa7748ca9bf9b592cbdc94707761495d6">rxr_ep_init</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep)</td></tr>
<tr class="memdesc:aa7748ca9bf9b592cbdc94707761495d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the endpoint.  <a href="rxr__ep_8c.html#aa7748ca9bf9b592cbdc94707761495d6">More...</a><br /></td></tr>
<tr class="separator:aa7748ca9bf9b592cbdc94707761495d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70e1198c97b0b3ea759b560f4441200"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#af70e1198c97b0b3ea759b560f4441200">rxr_ep_grow_rx_pkt_pools</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep)</td></tr>
<tr class="separator:af70e1198c97b0b3ea759b560f4441200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62252237cfe0e936de326cb0c2b3ea7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#ac62252237cfe0e936de326cb0c2b3ea7">rxr_ep_progress_internal</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep)</td></tr>
<tr class="separator:ac62252237cfe0e936de326cb0c2b3ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebac888745420d14c85b1f0605dfdf31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#aebac888745420d14c85b1f0605dfdf31">rxr_ep_progress</a> (struct util_ep *util_ep)</td></tr>
<tr class="separator:aebac888745420d14c85b1f0605dfdf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d9d19cb244c01b64d9ae41ab676dd7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#a55d9d19cb244c01b64d9ae41ab676dd7">rxr_endpoint</a> (struct fid_domain *domain, struct fi_info *info, struct fid_ep **ep, void *context)</td></tr>
<tr class="separator:a55d9d19cb244c01b64d9ae41ab676dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46c92cf96987535356526fdc53a60c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#ae46c92cf96987535356526fdc53a60c2">rxr_ep_record_tx_op_submitted</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry)</td></tr>
<tr class="memdesc:ae46c92cf96987535356526fdc53a60c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">record the event that a TX op has been submitted  <a href="rxr__ep_8c.html#ae46c92cf96987535356526fdc53a60c2">More...</a><br /></td></tr>
<tr class="separator:ae46c92cf96987535356526fdc53a60c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795da1231abf7d9b70b6ea48e8afdbfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#a795da1231abf7d9b70b6ea48e8afdbfb">rxr_ep_record_tx_op_completed</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry)</td></tr>
<tr class="memdesc:a795da1231abf7d9b70b6ea48e8afdbfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">record the event that an TX op is completed  <a href="rxr__ep_8c.html#a795da1231abf7d9b70b6ea48e8afdbfb">More...</a><br /></td></tr>
<tr class="separator:a795da1231abf7d9b70b6ea48e8afdbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4b4de9c40ff6dce3f66d68c983aaabfd"><td class="memItemLeft" align="right" valign="top">struct fi_ops_cm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__ep_8c.html#a4b4de9c40ff6dce3f66d68c983aaabfd">rxr_ep_cm</a></td></tr>
<tr class="separator:a4b4de9c40ff6dce3f66d68c983aaabfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="afc5f563dce1fe324483a2c05e95c1d6e" name="afc5f563dce1fe324483a2c05e95c1d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5f563dce1fe324483a2c05e95c1d6e">&#9670;&#160;</a></span>rxr_convert_desc_for_shm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_convert_desc_for_shm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>desc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert EFA descriptors to shm descriptors. </p>
<p >Each provider defines its descriptors format. The descriptor for EFA provider is of struct <a class="el" href="structefa__mr.html">efa_mr</a> *, which shm provider cannot understand. This function convert EFA descriptors to descriptors shm can use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numdesc[in]</td><td>number of descriptors in the array </td></tr>
    <tr><td class="paramname">desc[in,out]</td><td>descriptors input is EFA descriptor, output is shm descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55d9d19cb244c01b64d9ae41ab676dd7" name="a55d9d19cb244c01b64d9ae41ab676dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55d9d19cb244c01b64d9ae41ab676dd7">&#9670;&#160;</a></span>rxr_endpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rxr_endpoint </td>
          <td>(</td>
          <td class="paramtype">struct fid_domain *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct fi_info *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct fid_ep **&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55357c5aa066f0e245aa6ba65ac0aab6" name="a55357c5aa066f0e245aa6ba65ac0aab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55357c5aa066f0e245aa6ba65ac0aab6">&#9670;&#160;</a></span>rxr_ep_alloc_rx_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> * rxr_ep_alloc_rx_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fi_addr_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>allocate an rx entry for an operation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep[in]</td><td>end point </td></tr>
    <tr><td class="paramname">addr[in]</td><td>fi address of the sender/requester. </td></tr>
    <tr><td class="paramname">op[in]</td><td>operation type (ofi_op_msg/ofi_op_tagged/ofi_op_read/ofi_op_write/ofi_op_atomic_xxx) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if allocation succeeded, return pointer to rx_entry if allocation failed, return NULL </dd></dl>

</div>
</div>
<a id="ae18bc1a94a40cd37af3d3700e55040b3" name="ae18bc1a94a40cd37af3d3700e55040b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18bc1a94a40cd37af3d3700e55040b3">&#9670;&#160;</a></span>rxr_ep_alloc_tx_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> * rxr_ep_alloc_tx_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>rxr_ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct fi_msg *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee308149826f9e3869b4ecb3a4293a1c" name="aee308149826f9e3869b4ecb3a4293a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee308149826f9e3869b4ecb3a4293a1c">&#9670;&#160;</a></span>rxr_ep_determine_rdma_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rxr_ep_determine_rdma_support </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fi_addr_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrdm__peer.html">rdm_peer</a> *&#160;</td>
          <td class="paramname"><em>peer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af70e1198c97b0b3ea759b560f4441200" name="af70e1198c97b0b3ea759b560f4441200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70e1198c97b0b3ea759b560f4441200">&#9670;&#160;</a></span>rxr_ep_grow_rx_pkt_pools()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rxr_ep_grow_rx_pkt_pools </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7748ca9bf9b592cbdc94707761495d6" name="aa7748ca9bf9b592cbdc94707761495d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7748ca9bf9b592cbdc94707761495d6">&#9670;&#160;</a></span>rxr_ep_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rxr_ep_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the endpoint. </p>
<p >This function allocates the various buffer pools for the EFA and SHM provider and does other endpoint initialization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td><a class="el" href="structrxr__ep.html">rxr_ep</a> struct to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, fi_errno on error. </dd></dl>

</div>
</div>
<a id="aa51f27a322b72f2d177b7a19af596fcb" name="aa51f27a322b72f2d177b7a19af596fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51f27a322b72f2d177b7a19af596fcb">&#9670;&#160;</a></span>rxr_ep_post_internal_rx_pkt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rxr_ep_post_internal_rx_pkt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rxr_8h.html#a980c99793a2be650d15fdadba2b49fdb">rxr_lower_ep_type</a>&#160;</td>
          <td class="paramname"><em>lower_ep_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>post an internal receive buffer to lower endpoint </p>
<p >The buffer was posted as undirected recv, (address was set to FI_ADDR_UNSPEC)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>flags passed to lower provider, can have FI_MORE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lower_ep_type</td><td>lower endpoint type, can be either SHM_EP or EFA_EP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, return 0 On failure, return a negative error code. </dd></dl>

</div>
</div>
<a id="a496fc2f47ea12949902f83bf0051c5f7" name="a496fc2f47ea12949902f83bf0051c5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496fc2f47ea12949902f83bf0051c5f7">&#9670;&#160;</a></span>rxr_ep_post_user_recv_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rxr_ep_post_user_recv_buf </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *&#160;</td>
          <td class="paramname"><em>rx_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>post user provided receiving buffer to the device. </p>
<p >The user receive buffer was converted to an RX packet, then posted to the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rx_entry</td><td>rx_entry that contain user buffer information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>user supplied flags passed to fi_recv </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebac888745420d14c85b1f0605dfdf31" name="aebac888745420d14c85b1f0605dfdf31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebac888745420d14c85b1f0605dfdf31">&#9670;&#160;</a></span>rxr_ep_progress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_ep_progress </td>
          <td>(</td>
          <td class="paramtype">struct util_ep *&#160;</td>
          <td class="paramname"><em>util_ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac62252237cfe0e936de326cb0c2b3ea7" name="ac62252237cfe0e936de326cb0c2b3ea7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62252237cfe0e936de326cb0c2b3ea7">&#9670;&#160;</a></span>rxr_ep_progress_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_ep_progress_internal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab6d07476c1eec64a8c1c9bb80f0c47a2" name="ab6d07476c1eec64a8c1c9bb80f0c47a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d07476c1eec64a8c1c9bb80f0c47a2">&#9670;&#160;</a></span>rxr_ep_raw_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structefa__ep__addr.html">efa_ep_addr</a> * rxr_ep_raw_addr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3436edef34b25360d62a6668532fbe43" name="a3436edef34b25360d62a6668532fbe43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3436edef34b25360d62a6668532fbe43">&#9670;&#160;</a></span>rxr_ep_raw_addr_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * rxr_ep_raw_addr_str </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a795da1231abf7d9b70b6ea48e8afdbfb" name="a795da1231abf7d9b70b6ea48e8afdbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795da1231abf7d9b70b6ea48e8afdbfb">&#9670;&#160;</a></span>rxr_ep_record_tx_op_completed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_ep_record_tx_op_completed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>record the event that an TX op is completed </p>
<p >This function is called when the completion of a TX operation is received. It will</p>
<ol type="1">
<li>decrease the outstanding tx_op counter in the endpoint and in the peer.</li>
<li>remove the TX packet from peer's outstanding TX packet list.</li>
</ol>
<p >Both send and read are considered TX operation.</p>
<p >One may ask why this function is not integrated into rxr_pkt_entry_relase_tx()?</p>
<p >The reason is the action of decrease tx_op counter is not tied to releasing a TX pkt_entry.</p>
<p >Sometimes we need to decreate the tx_op counter without releasing a TX pkt_entry. For example, we handle a TX pkt_entry encountered RNR. We need to decrease the tx_op counter and queue the packet.</p>
<p >Sometimes we need release TX pkt_entry without decreasing the tx_op counter. For example, when <a class="el" href="rxr__pkt__cmd_8c.html#ab67a92bed9e1cb806de815156da7b312" title="post packet(s) according to packet type.">rxr_pkt_post()</a> failed to post a pkt entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ep</td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_entry</td><td>TX pkt_entry, which contains the info of the TX op </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae46c92cf96987535356526fdc53a60c2" name="ae46c92cf96987535356526fdc53a60c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46c92cf96987535356526fdc53a60c2">&#9670;&#160;</a></span>rxr_ep_record_tx_op_submitted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_ep_record_tx_op_submitted </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>record the event that a TX op has been submitted </p>
<p >This function is called after a TX operation has been posted successfully. It will:</p>
<ol type="1">
<li>increase the outstanding tx_op counter in endpoint and in the peer structure.</li>
<li>add the TX packet to peer's outstanding TX packet list.</li>
</ol>
<p >Both send and read are considered TX operation.</p>
<p >The tx_op counters used to prevent over posting the device and used in flow control. They are also usefull for debugging.</p>
<p >Peer's outstanding TX packet list is used when removing a peer to invalidate address of these packets, so that the completion of these packet is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ep</td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_entry</td><td>TX pkt_entry, which contains the info of the TX op. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a338ba2f3ae4f3af39b7ca5550cb6f25b" name="a338ba2f3ae4f3af39b7ca5550cb6f25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a338ba2f3ae4f3af39b7ca5550cb6f25b">&#9670;&#160;</a></span>rxr_peer_raw_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structefa__ep__addr.html">efa_ep_addr</a> * rxr_peer_raw_addr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fi_addr_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad45efbb4791011739590a6bea6731d9f" name="ad45efbb4791011739590a6bea6731d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45efbb4791011739590a6bea6731d9f">&#9670;&#160;</a></span>rxr_peer_raw_addr_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * rxr_peer_raw_addr_str </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fi_addr_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2b4bdf8f4f8f126260739b4703af20f" name="ab2b4bdf8f4f8f126260739b4703af20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b4bdf8f4f8f126260739b4703af20f">&#9670;&#160;</a></span>rxr_prepare_desc_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_prepare_desc_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__domain.html">efa_domain</a> *&#160;</td>
          <td class="paramname"><em>efa_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *&#160;</td>
          <td class="paramname"><em>tx_entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a736977c53d826fdea255b8ac76ffe0d3" name="a736977c53d826fdea255b8ac76ffe0d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736977c53d826fdea255b8ac76ffe0d3">&#9670;&#160;</a></span>rxr_release_tx_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_release_tx_entry </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *&#160;</td>
          <td class="paramname"><em>tx_entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34444e71608340ae389f977191fac2b8" name="a34444e71608340ae389f977191fac2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34444e71608340ae389f977191fac2b8">&#9670;&#160;</a></span>rxr_tx_entry_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_tx_entry_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *&#160;</td>
          <td class="paramname"><em>tx_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct fi_msg *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4b4de9c40ff6dce3f66d68c983aaabfd" name="a4b4de9c40ff6dce3f66d68c983aaabfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4de9c40ff6dce3f66d68c983aaabfd">&#9670;&#160;</a></span>rxr_ep_cm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fi_ops_cm rxr_ep_cm</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    .size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>fi_ops_cm),</div>
<div class="line">    .setname = rxr_ep_rdm_setname,</div>
<div class="line">    .getname = rxr_ep_rdm_getname,</div>
<div class="line">    .getpeer = fi_no_getpeer,</div>
<div class="line">    .connect = fi_no_connect,</div>
<div class="line">    .listen = fi_no_listen,</div>
<div class="line">    .accept = fi_no_accept,</div>
<div class="line">    .reject = fi_no_reject,</div>
<div class="line">    .shutdown = fi_no_shutdown,</div>
<div class="line">    .join = fi_no_join,</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
