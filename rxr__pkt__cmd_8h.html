<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Libfabric EFA Provider: prov/efa/src/rxr/rxr_pkt_cmd.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Libfabric EFA Provider
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d46679ce1435edc13ddade6ebade25f4.html">prov</a></li><li class="navelem"><a class="el" href="dir_d7cf6fdb83f41a3999019906e7af8b56.html">efa</a></li><li class="navelem"><a class="el" href="dir_b78761dad90496b57e16a2b87cb4161d.html">src</a></li><li class="navelem"><a class="el" href="dir_5e6ba55d6661b4254686e3fa900dc191.html">rxr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">rxr_pkt_cmd.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="rxr_8h_source.html">rxr.h</a>&quot;</code><br />
</div>
<p><a href="rxr__pkt__cmd_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab67a92bed9e1cb806de815156da7b312"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__cmd_8h.html#ab67a92bed9e1cb806de815156da7b312">rxr_pkt_post</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *op_entry, int pkt_type, bool inject, uint64_t flags)</td></tr>
<tr class="memdesc:ab67a92bed9e1cb806de815156da7b312"><td class="mdescLeft">&#160;</td><td class="mdescRight">post packet(s) according to packet type.  <a href="rxr__pkt__cmd_8h.html#ab67a92bed9e1cb806de815156da7b312">More...</a><br /></td></tr>
<tr class="separator:ab67a92bed9e1cb806de815156da7b312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4daae0828e46336171deb8f9f521477"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__cmd_8h.html#ad4daae0828e46336171deb8f9f521477">rxr_pkt_post_or_queue</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *op_entry, int req_type, bool inject)</td></tr>
<tr class="memdesc:ad4daae0828e46336171deb8f9f521477"><td class="mdescLeft">&#160;</td><td class="mdescRight">post packet(s) according to packet type. Queue the post if -FI_EAGAIN is encountered.  <a href="rxr__pkt__cmd_8h.html#ad4daae0828e46336171deb8f9f521477">More...</a><br /></td></tr>
<tr class="separator:ad4daae0828e46336171deb8f9f521477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399c971569d850dc4cd1fa4e91c467b1"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__cmd_8h.html#a399c971569d850dc4cd1fa4e91c467b1">rxr_pkt_post_req</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *tx_entry, int req_type, bool inject, uint64_t flags)</td></tr>
<tr class="memdesc:a399c971569d850dc4cd1fa4e91c467b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">post req packet(s). Queue the post for multi-req packet types  <a href="rxr__pkt__cmd_8h.html#a399c971569d850dc4cd1fa4e91c467b1">More...</a><br /></td></tr>
<tr class="separator:a399c971569d850dc4cd1fa4e91c467b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e736f18b079c801f0ecdda726717a7"><td class="memItemLeft" align="right" valign="top">fi_addr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__cmd_8h.html#a24e736f18b079c801f0ecdda726717a7">rxr_pkt_determine_addr</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry)</td></tr>
<tr class="memdesc:a24e736f18b079c801f0ecdda726717a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read peer raw address from packet header and insert the peer in AV.  <a href="rxr__pkt__cmd_8h.html#a24e736f18b079c801f0ecdda726717a7">More...</a><br /></td></tr>
<tr class="separator:a24e736f18b079c801f0ecdda726717a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779e51914e18809573569b2bd1439a12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__cmd_8h.html#a779e51914e18809573569b2bd1439a12">rxr_pkt_handle_data_copied</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry, size_t data_size)</td></tr>
<tr class="separator:a779e51914e18809573569b2bd1439a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a084252ee46a68a0280345b9813dbbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__cmd_8h.html#a9a084252ee46a68a0280345b9813dbbb">rxr_pkt_handle_send_error</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry, int err, int prov_errno)</td></tr>
<tr class="memdesc:a9a084252ee46a68a0280345b9813dbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the a packet that encountered error completion while sending  <a href="rxr__pkt__cmd_8h.html#a9a084252ee46a68a0280345b9813dbbb">More...</a><br /></td></tr>
<tr class="separator:a9a084252ee46a68a0280345b9813dbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d17cac6b2e3b9b5fa7198f0195ce754"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__cmd_8h.html#a7d17cac6b2e3b9b5fa7198f0195ce754">rxr_pkt_handle_send_completion</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry)</td></tr>
<tr class="separator:a7d17cac6b2e3b9b5fa7198f0195ce754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f40a37a9454f3fc58b5b918f7e558df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__cmd_8h.html#a8f40a37a9454f3fc58b5b918f7e558df">rxr_pkt_handle_recv_error</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry, int err, int prov_errno)</td></tr>
<tr class="memdesc:a8f40a37a9454f3fc58b5b918f7e558df"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the a packet that encountered error completion while receiving  <a href="rxr__pkt__cmd_8h.html#a8f40a37a9454f3fc58b5b918f7e558df">More...</a><br /></td></tr>
<tr class="separator:a8f40a37a9454f3fc58b5b918f7e558df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649e3cf2f9a6e28e49301825ca0c81e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__cmd_8h.html#a649e3cf2f9a6e28e49301825ca0c81e7">rxr_pkt_handle_recv_completion</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *pkt_entry, enum <a class="el" href="rxr_8h.html#a980c99793a2be650d15fdadba2b49fdb">rxr_lower_ep_type</a> lower_ep_type)</td></tr>
<tr class="memdesc:a649e3cf2f9a6e28e49301825ca0c81e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle a received packet  <a href="rxr__pkt__cmd_8h.html#a649e3cf2f9a6e28e49301825ca0c81e7">More...</a><br /></td></tr>
<tr class="separator:a649e3cf2f9a6e28e49301825ca0c81e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac995ebabcb1454530c548107591df17"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__cmd_8h.html#aac995ebabcb1454530c548107591df17">rxr_pkt_wait_handshake</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, fi_addr_t addr, struct <a class="el" href="structrdm__peer.html">rdm_peer</a> *peer)</td></tr>
<tr class="separator:aac995ebabcb1454530c548107591df17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa4c8a003fa9b6d37fd75f00fe0f45f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rxr__pkt__cmd_8h.html#a0fa4c8a003fa9b6d37fd75f00fe0f45f">rxr_pkt_trigger_handshake</a> (struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *ep, fi_addr_t addr, struct <a class="el" href="structrdm__peer.html">rdm_peer</a> *peer)</td></tr>
<tr class="separator:a0fa4c8a003fa9b6d37fd75f00fe0f45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a24e736f18b079c801f0ecdda726717a7" name="a24e736f18b079c801f0ecdda726717a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e736f18b079c801f0ecdda726717a7">&#9670;&#160;</a></span>rxr_pkt_determine_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fi_addr_t rxr_pkt_determine_addr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read peer raw address from packet header and insert the peer in AV. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Pointer to RDM endpoint </td></tr>
    <tr><td class="paramname">pkt_entry</td><td>Pointer to packet entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Peer address, or FI_ADDR_NOTAVIL if the packet header does not include raw address </dd></dl>

</div>
</div>
<a id="a779e51914e18809573569b2bd1439a12" name="a779e51914e18809573569b2bd1439a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779e51914e18809573569b2bd1439a12">&#9670;&#160;</a></span>rxr_pkt_handle_data_copied()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_pkt_handle_data_copied </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a649e3cf2f9a6e28e49301825ca0c81e7" name="a649e3cf2f9a6e28e49301825ca0c81e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649e3cf2f9a6e28e49301825ca0c81e7">&#9670;&#160;</a></span>rxr_pkt_handle_recv_completion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_pkt_handle_recv_completion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rxr_8h.html#a980c99793a2be650d15fdadba2b49fdb">rxr_lower_ep_type</a>&#160;</td>
          <td class="paramname"><em>lower_ep_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>handle a received packet </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep[in,out]</td><td>endpoint </td></tr>
    <tr><td class="paramname">pkt_entry[in,out]</td><td>received packet, will be released by this function </td></tr>
    <tr><td class="paramname">lower_ep_type[in]</td><td>indicates which type of lower device this packet was received from. Possible values are SHM_EP and EFA_EP. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f40a37a9454f3fc58b5b918f7e558df" name="a8f40a37a9454f3fc58b5b918f7e558df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f40a37a9454f3fc58b5b918f7e558df">&#9670;&#160;</a></span>rxr_pkt_handle_recv_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_pkt_handle_recv_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prov_errno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>handle the a packet that encountered error completion while receiving </p>
<p >This function will write error cq or eq entry, then release the packet entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_entry</td><td>pkt entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>libfabric error code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prov_errno</td><td>provider specific error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d17cac6b2e3b9b5fa7198f0195ce754" name="a7d17cac6b2e3b9b5fa7198f0195ce754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d17cac6b2e3b9b5fa7198f0195ce754">&#9670;&#160;</a></span>rxr_pkt_handle_send_completion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_pkt_handle_send_completion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a084252ee46a68a0280345b9813dbbb" name="a9a084252ee46a68a0280345b9813dbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a084252ee46a68a0280345b9813dbbb">&#9670;&#160;</a></span>rxr_pkt_handle_send_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rxr_pkt_handle_send_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__pkt__entry.html">rxr_pkt_entry</a> *&#160;</td>
          <td class="paramname"><em>pkt_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prov_errno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>handle the a packet that encountered error completion while sending </p>
<p >Depend on the packet type and error type, the error are handled differently.</p>
<p >If the packet is associated with an user initialized TX operation: (TX means send,read or write; such packets include all REQ packets and DATA):</p>
<p >If the error is Receiver Not Ready (RNR). there are two cases: </p><pre class="fragment"> If user wants to manager RNR by itself (FI_RM_DISABLED),
 an error CQ entry will be written.

 Otherwise, the packet will be queued and resent by progress engine.
</pre><p> For other type of error, an error CQ entry is written.</p>
<p >If the packet is associated with an user initialized recv operiaton, (such packets include EOR, CTS): </p><pre class="fragment"> If the error is RNR, the packet is queued and resent by progress
 engine. No CQ entry is written.

 For other types of error, an error CQ entry is written.
</pre><p> If the packet is not associated with a user operation (such packet include HANDSHAKE): </p><pre class="fragment"> If the error is RNR, the packet is queued and resent by progress engine.

 For other types of error, an error EQ entry is written.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_entry</td><td>pkt entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>libfabric error code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prov_errno</td><td>provider specific error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab67a92bed9e1cb806de815156da7b312" name="ab67a92bed9e1cb806de815156da7b312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67a92bed9e1cb806de815156da7b312">&#9670;&#160;</a></span>rxr_pkt_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rxr_pkt_post </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *&#160;</td>
          <td class="paramname"><em>op_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pkt_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>post packet(s) according to packet type. </p>
<p >Depend on packet type, this function may post one packet or multiple packets. This is because some REQ packet types such as MEDIUM RTM must be sent as a series of packets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="structrxr__ep.html">rxr_ep</a></td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_entry</td><td>pointer to <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a>. (either a tx_entry or an rx_entry) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_type</td><td>packet type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inject</td><td>send control packet via inject or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success return 0, otherwise return a negative libfabric error code. Possible error codes include: -FI_EAGAIN temporarily out of resource </dd></dl>

</div>
</div>
<a id="ad4daae0828e46336171deb8f9f521477" name="ad4daae0828e46336171deb8f9f521477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4daae0828e46336171deb8f9f521477">&#9670;&#160;</a></span>rxr_pkt_post_or_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rxr_pkt_post_or_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *&#160;</td>
          <td class="paramname"><em>op_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pkt_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>post packet(s) according to packet type. Queue the post if -FI_EAGAIN is encountered. </p>
<p >This function will cal <a class="el" href="rxr__pkt__cmd_8c.html#ab67a92bed9e1cb806de815156da7b312" title="post packet(s) according to packet type.">rxr_pkt_post()</a> to post packet(s) according to packet type. If <a class="el" href="rxr__pkt__cmd_8c.html#ab67a92bed9e1cb806de815156da7b312" title="post packet(s) according to packet type.">rxr_pkt_post()</a> returned -FI_EAGAIN, this function will put the tx_entry in <a class="el" href="structrxr__ep.html">rxr_ep</a>'s queued_ctrl_list. The progress engine will try to post the packet later.</p>
<p >This function is called by <a class="el" href="rxr__pkt__cmd_8c.html#a3ea047bf25cbbeee8366e877be8a91ac" title="post req packet(s). Queue the post for multi-req packet types">rxr_pkt_post_req()</a> to post MEDIUM RTM packets, and is called by packet handler to post responsive ctrl packet (such as EOR and CTS).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="structrxr__ep.html">rxr_ep</a></td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_entry</td><td>pointer to <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a>. (either a tx_entry or an rx_entry) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_type</td><td>packet type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inject</td><td>send control packet via inject or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success return 0, otherwise return a negative libfabric error code. </dd></dl>

</div>
</div>
<a id="a399c971569d850dc4cd1fa4e91c467b1" name="a399c971569d850dc4cd1fa4e91c467b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399c971569d850dc4cd1fa4e91c467b1">&#9670;&#160;</a></span>rxr_pkt_post_req()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rxr_pkt_post_req </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a> *&#160;</td>
          <td class="paramname"><em>op_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>req_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>post req packet(s). Queue the post for multi-req packet types </p>
<p >We must use <a class="el" href="rxr__pkt__cmd_8c.html#a31dff9e5fee64e9c3d0bfc93d5a4fc61" title="post packet(s) according to packet type. Queue the post if -FI_EAGAIN is encountered.">rxr_pkt_post_or_queue()</a> for multi-req packet types.</p>
<p >This is because for multi-req packets, <a class="el" href="rxr__pkt__cmd_8c.html#ab67a92bed9e1cb806de815156da7b312" title="post packet(s) according to packet type.">rxr_pkt_post()</a> will send multiple packets.</p>
<p >It can happen that 1st packet was sent successfully, and the next one encountered -FI_EAGAIN, which will cause <a class="el" href="rxr__pkt__cmd_8c.html#ab67a92bed9e1cb806de815156da7b312" title="post packet(s) according to packet type.">rxr_pkt_post()</a> to return -FI_EAGAIN.</p>
<p >If <a class="el" href="rxr__pkt__cmd_8c.html#ab67a92bed9e1cb806de815156da7b312" title="post packet(s) according to packet type.">rxr_pkt_post()</a> was used by this function, the -FI_EAGAIN will be returned to user application. User application will then send the entire message again. This would cause the receiver to receive duplicated packets (because 1st packet was sent successfully).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"><a class="el" href="structrxr__ep.html">rxr_ep</a></td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_entry</td><td>pointer to <a class="el" href="structrxr__op__entry.html">rxr_op_entry</a>. (either a tx_entry or an rx_entry) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_type</td><td>packet type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inject</td><td>send control packet via inject or not. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success return 0, otherwise return a negative libfabric error code. </dd></dl>

</div>
</div>
<a id="a0fa4c8a003fa9b6d37fd75f00fe0f45f" name="a0fa4c8a003fa9b6d37fd75f00fe0f45f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa4c8a003fa9b6d37fd75f00fe0f45f">&#9670;&#160;</a></span>rxr_pkt_trigger_handshake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rxr_pkt_trigger_handshake </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fi_addr_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrdm__peer.html">rdm_peer</a> *&#160;</td>
          <td class="paramname"><em>peer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac995ebabcb1454530c548107591df17" name="aac995ebabcb1454530c548107591df17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac995ebabcb1454530c548107591df17">&#9670;&#160;</a></span>rxr_pkt_wait_handshake()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rxr_pkt_wait_handshake </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrxr__ep.html">rxr_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fi_addr_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrdm__peer.html">rdm_peer</a> *&#160;</td>
          <td class="paramname"><em>peer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
