<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Libfabric EFA Provider: prov/efa/src/rdm/efa_rdm_ope.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Libfabric EFA Provider
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b381ef8083dea485196d236b9877555e.html">prov</a></li><li class="navelem"><a class="el" href="dir_a515239317c856b6e80d7e87f6229fcf.html">efa</a></li><li class="navelem"><a class="el" href="dir_268213be7ca109d6848bb43595209f5b.html">src</a></li><li class="navelem"><a class="el" href="dir_2a8709364a10ee80619c78ae399489f1.html">rdm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">efa_rdm_ope.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="efa__rdm__pke_8h_source.html">efa_rdm_pke.h</a>&quot;</code><br/>
</div>
<p><a href="efa__rdm__ope_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__atomic__hdr.html">efa_rdm_atomic_hdr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">basic information of an atomic operation used by all 3 types of atomic operations: fetch, compare and write  <a href="structefa__rdm__atomic__hdr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__atomic__ex.html">efa_rdm_atomic_ex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">extra information that is not included in fi_msg_atomic used by fetch atomic and compare atomic. resp stands for response comp stands for compare  <a href="structefa__rdm__atomic__ex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">EFA RDM operation entry (ope)  <a href="structefa__rdm__ope.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a64c8835fcb4546cbdfdc6b073c7e9e00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a64c8835fcb4546cbdfdc6b073c7e9e00">EFA_RDM_IOV_LIMIT</a>&#160;&#160;&#160;(4)</td></tr>
<tr class="separator:a64c8835fcb4546cbdfdc6b073c7e9e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de598edaa9e8efe2998a538dcc8b86e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a0de598edaa9e8efe2998a538dcc8b86e">EFA_RDM_RXE_RECV_CANCEL</a>&#160;&#160;&#160;BIT_ULL(3)</td></tr>
<tr class="memdesc:a0de598edaa9e8efe2998a538dcc8b86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">indicate an ope's receive has been cancel  <a href="#a0de598edaa9e8efe2998a538dcc8b86e">More...</a><br/></td></tr>
<tr class="separator:a0de598edaa9e8efe2998a538dcc8b86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cabd432fbc4a16bb4a2386236c4293"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a18cabd432fbc4a16bb4a2386236c4293">EFA_RDM_TXE_DELIVERY_COMPLETE_REQUESTED</a>&#160;&#160;&#160;BIT_ULL(6)</td></tr>
<tr class="memdesc:a18cabd432fbc4a16bb4a2386236c4293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to tell if the transmission is using FI_DELIVERY_COMPLETE protocols.  <a href="#a18cabd432fbc4a16bb4a2386236c4293">More...</a><br/></td></tr>
<tr class="separator:a18cabd432fbc4a16bb4a2386236c4293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0dec9475fb43f471d8d69ca67d4f68"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a9c0dec9475fb43f471d8d69ca67d4f68">EFA_RDM_OPE_QUEUED_RNR</a>&#160;&#160;&#160;BIT_ULL(9)</td></tr>
<tr class="memdesc:a9c0dec9475fb43f471d8d69ca67d4f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to tell if an ope encouter RNR when sending packets  <a href="#a9c0dec9475fb43f471d8d69ca67d4f68">More...</a><br/></td></tr>
<tr class="separator:a9c0dec9475fb43f471d8d69ca67d4f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4754c8ac80dd5c45094e5d610288f930"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a4754c8ac80dd5c45094e5d610288f930">EFA_RDM_RXE_EOR_IN_FLIGHT</a>&#160;&#160;&#160;BIT_ULL(10)</td></tr>
<tr class="memdesc:a4754c8ac80dd5c45094e5d610288f930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to indicate an rxe has an EOR in flight.  <a href="#a4754c8ac80dd5c45094e5d610288f930">More...</a><br/></td></tr>
<tr class="separator:a4754c8ac80dd5c45094e5d610288f930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9093708d84fbe511f92aa95aedaf2f49"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a9093708d84fbe511f92aa95aedaf2f49">EFA_RDM_TXE_WRITTEN_RNR_CQ_ERR_ENTRY</a>&#160;&#160;&#160;BIT_ULL(10)</td></tr>
<tr class="memdesc:a9093708d84fbe511f92aa95aedaf2f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate a txe has already written an cq error entry for RNR  <a href="#a9093708d84fbe511f92aa95aedaf2f49">More...</a><br/></td></tr>
<tr class="separator:a9093708d84fbe511f92aa95aedaf2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42060b5cba9e88391dfb6777ba3ce23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#ad42060b5cba9e88391dfb6777ba3ce23">EFA_RDM_OPE_QUEUED_CTRL</a>&#160;&#160;&#160;BIT_ULL(11)</td></tr>
<tr class="memdesc:ad42060b5cba9e88391dfb6777ba3ce23"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate an ope has queued ctrl packet,  <a href="#ad42060b5cba9e88391dfb6777ba3ce23">More...</a><br/></td></tr>
<tr class="separator:ad42060b5cba9e88391dfb6777ba3ce23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c1d29f95da6003c0cc87312d20f9f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#ab8c1d29f95da6003c0cc87312d20f9f0">EFA_RDM_TXE_NO_COMPLETION</a>&#160;&#160;&#160;BIT_ULL(60)</td></tr>
<tr class="memdesc:ab8c1d29f95da6003c0cc87312d20f9f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate an ope does not need to report completion to user  <a href="#ab8c1d29f95da6003c0cc87312d20f9f0">More...</a><br/></td></tr>
<tr class="separator:ab8c1d29f95da6003c0cc87312d20f9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc4677513b3d906707808b8ba538c95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a2dc4677513b3d906707808b8ba538c95">EFA_RDM_TXE_NO_COUNTER</a>&#160;&#160;&#160;BIT_ULL(61)</td></tr>
<tr class="memdesc:a2dc4677513b3d906707808b8ba538c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate an ope does not need to increase counter  <a href="#a2dc4677513b3d906707808b8ba538c95">More...</a><br/></td></tr>
<tr class="separator:a2dc4677513b3d906707808b8ba538c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698bbdebcd57b56b76884237ba709696"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a698bbdebcd57b56b76884237ba709696">EFA_RDM_OPE_QUEUED_READ</a>&#160;&#160;&#160;BIT_ULL(12)</td></tr>
<tr class="memdesc:a698bbdebcd57b56b76884237ba709696"><td class="mdescLeft">&#160;</td><td class="mdescRight">flag to indicate an ope has queued read requests  <a href="#a698bbdebcd57b56b76884237ba709696">More...</a><br/></td></tr>
<tr class="separator:a698bbdebcd57b56b76884237ba709696"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a3560fc43be30d9394c75582ad73c1e4e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a3560fc43be30d9394c75582ad73c1e4e">efa_rdm_ope_type</a> { <a class="el" href="efa__rdm__ope_8h.html#a3560fc43be30d9394c75582ad73c1e4ea504f600f59c06030e4fc9be918617c91">EFA_RDM_TXE</a> = 1, 
<a class="el" href="efa__rdm__ope_8h.html#a3560fc43be30d9394c75582ad73c1e4ea283ee9d48b376f2ba4dddbc88001b198">EFA_RDM_RXE</a>
 }</td></tr>
<tr class="memdesc:a3560fc43be30d9394c75582ad73c1e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">EFA RDM operation entry (ope) type.  <a href="efa__rdm__ope_8h.html#a3560fc43be30d9394c75582ad73c1e4e">More...</a><br/></td></tr>
<tr class="separator:a3560fc43be30d9394c75582ad73c1e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9901821c399c33346c2a539e688a30"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a6c9901821c399c33346c2a539e688a30">efa_rdm_ope_state</a> { <br/>
&#160;&#160;<a class="el" href="efa__rdm__ope_8h.html#a6c9901821c399c33346c2a539e688a30a4df26b738b43152b2eae14bdadaa08d8">EFA_RDM_OPE_FREE</a> = 0, 
<a class="el" href="efa__rdm__ope_8h.html#a6c9901821c399c33346c2a539e688a30a6edc952c1fffee5962bb6360d9c13846">EFA_RDM_TXE_REQ</a>, 
<a class="el" href="efa__rdm__ope_8h.html#a6c9901821c399c33346c2a539e688a30a4c6f11bd54a0d7f75fb8c08f758d2c48">EFA_RDM_TXE_SEND</a>, 
<a class="el" href="efa__rdm__ope_8h.html#a6c9901821c399c33346c2a539e688a30a0709e08ce9b65224aa3da2d60a489989">EFA_RDM_RXE_INIT</a>, 
<br/>
&#160;&#160;<a class="el" href="efa__rdm__ope_8h.html#a6c9901821c399c33346c2a539e688a30a6351d6db7d4eb41e6f52172fb95c182a">EFA_RDM_RXE_UNEXP</a>, 
<a class="el" href="efa__rdm__ope_8h.html#a6c9901821c399c33346c2a539e688a30a1754f19e6e9fcd2cfe7f9b74fb6eb61e">EFA_RDM_RXE_MATCHED</a>, 
<a class="el" href="efa__rdm__ope_8h.html#a6c9901821c399c33346c2a539e688a30a804793464095cfae2c76d05989523d75">EFA_RDM_RXE_RECV</a>
<br/>
 }</td></tr>
<tr class="memdesc:a6c9901821c399c33346c2a539e688a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">EFA RDM operation entry (ope)'s state.  <a href="efa__rdm__ope_8h.html#a6c9901821c399c33346c2a539e688a30">More...</a><br/></td></tr>
<tr class="separator:a6c9901821c399c33346c2a539e688a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa7c40e76455a0248fb496a26d9583b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#acfa7c40e76455a0248fb496a26d9583b">efa_rdm_cuda_copy_method</a> { <a class="el" href="efa__rdm__ope_8h.html#acfa7c40e76455a0248fb496a26d9583ba573464aa8f589eab378cf87a879a0115">EFA_RDM_CUDA_COPY_UNSPEC</a> = 0, 
<a class="el" href="efa__rdm__ope_8h.html#acfa7c40e76455a0248fb496a26d9583ba49b4d615ffb2b73de7cd5417984faa28">EFA_RDM_CUDA_COPY_BLOCKING</a>, 
<a class="el" href="efa__rdm__ope_8h.html#acfa7c40e76455a0248fb496a26d9583ba6aae189b87b22b4c1d5391d651018448">EFA_RDM_CUDA_COPY_LOCALREAD</a>
 }</td></tr>
<tr class="memdesc:acfa7c40e76455a0248fb496a26d9583b"><td class="mdescLeft">&#160;</td><td class="mdescRight">how to copy data from bounce buffer to CUDA receive buffer  <a href="efa__rdm__ope_8h.html#acfa7c40e76455a0248fb496a26d9583b">More...</a><br/></td></tr>
<tr class="separator:acfa7c40e76455a0248fb496a26d9583b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa0332d3ff554093510a6436960603237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#aa0332d3ff554093510a6436960603237">efa_rdm_txe_construct</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *txe, struct <a class="el" href="structefa__rdm__ep.html">efa_rdm_ep</a> *ep, const struct fi_msg *msg, uint32_t op, uint64_t flags)</td></tr>
<tr class="separator:aa0332d3ff554093510a6436960603237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad8d0b1851916f68fa90360cdac2b49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a2ad8d0b1851916f68fa90360cdac2b49">efa_rdm_txe_release</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *txe)</td></tr>
<tr class="separator:a2ad8d0b1851916f68fa90360cdac2b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49897eb45f4740c247a8dea7acd0525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#aa49897eb45f4740c247a8dea7acd0525">efa_rdm_rxe_release</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *rxe)</td></tr>
<tr class="separator:aa49897eb45f4740c247a8dea7acd0525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45c8089fbd0d68575a04896129a5702"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#aa45c8089fbd0d68575a04896129a5702">efa_rdm_rxe_release_internal</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *rxe)</td></tr>
<tr class="memdesc:aa45c8089fbd0d68575a04896129a5702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the efa specific resources in efa_rdm_rxe.  <a href="#aa45c8089fbd0d68575a04896129a5702">More...</a><br/></td></tr>
<tr class="separator:aa45c8089fbd0d68575a04896129a5702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ee83f8ce8dcf17f32aeed13cc01614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a20ee83f8ce8dcf17f32aeed13cc01614">efa_rdm_ope_try_fill_desc</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope, int mr_iov_start, uint64_t access)</td></tr>
<tr class="memdesc:a20ee83f8ce8dcf17f32aeed13cc01614"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to fill the desc field of an ope by memory registration  <a href="#a20ee83f8ce8dcf17f32aeed13cc01614">More...</a><br/></td></tr>
<tr class="separator:a20ee83f8ce8dcf17f32aeed13cc01614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec7f1fe0929a0e9126384b9a2a66e38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#afec7f1fe0929a0e9126384b9a2a66e38">efa_rdm_txe_prepare_to_be_read</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *txe, struct fi_rma_iov *read_iov)</td></tr>
<tr class="separator:afec7f1fe0929a0e9126384b9a2a66e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae70fc78d870cb49a86d4207b83db307"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#aae70fc78d870cb49a86d4207b83db307">efa_rdm_ope_mulreq_total_data_size</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope, int pkt_type)</td></tr>
<tr class="memdesc:aae70fc78d870cb49a86d4207b83db307"><td class="mdescLeft">&#160;</td><td class="mdescRight">total data size that will be sent/received via the multiple REQ packets  <a href="#aae70fc78d870cb49a86d4207b83db307">More...</a><br/></td></tr>
<tr class="separator:aae70fc78d870cb49a86d4207b83db307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae642be6908c005bfa49847c841df60b6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#ae642be6908c005bfa49847c841df60b6">efa_rdm_txe_max_req_data_capacity</a> (struct <a class="el" href="structefa__rdm__ep.html">efa_rdm_ep</a> *ep, struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *txe, int pkt_type)</td></tr>
<tr class="memdesc:ae642be6908c005bfa49847c841df60b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the maximum data capacity of a REQ packet for an send operation  <a href="#ae642be6908c005bfa49847c841df60b6">More...</a><br/></td></tr>
<tr class="separator:ae642be6908c005bfa49847c841df60b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c6d10e4eff9aca604509f7c40ead4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#aa5c6d10e4eff9aca604509f7c40ead4d">efa_rdm_txe_handle_error</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *txe, int <a class="el" href="efa__prov_8c.html#a52482fdd3721e7db69dc740aefee8ad4">err</a>, int prov_errno)</td></tr>
<tr class="memdesc:aa5c6d10e4eff9aca604509f7c40ead4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the situation that a TX operation encountered error  <a href="#aa5c6d10e4eff9aca604509f7c40ead4d">More...</a><br/></td></tr>
<tr class="separator:aa5c6d10e4eff9aca604509f7c40ead4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7deb054533b43c65d81e077df3a0a05a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a7deb054533b43c65d81e077df3a0a05a">efa_rdm_rxe_handle_error</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *rxe, int <a class="el" href="efa__prov_8c.html#a52482fdd3721e7db69dc740aefee8ad4">err</a>, int prov_errno)</td></tr>
<tr class="memdesc:a7deb054533b43c65d81e077df3a0a05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the situation that an error has happened to an RX (receive) operation  <a href="#a7deb054533b43c65d81e077df3a0a05a">More...</a><br/></td></tr>
<tr class="separator:a7deb054533b43c65d81e077df3a0a05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2a2c841aa88840057302b4415582b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#aac2a2c841aa88840057302b4415582b5">efa_rdm_txe_report_completion</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *txe)</td></tr>
<tr class="memdesc:aac2a2c841aa88840057302b4415582b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">report (to user) that a TX operation has completed  <a href="#aac2a2c841aa88840057302b4415582b5">More...</a><br/></td></tr>
<tr class="separator:aac2a2c841aa88840057302b4415582b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f70b1020467a972266d68b8c3ead0df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a4f70b1020467a972266d68b8c3ead0df">efa_rdm_rxe_report_completion</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *rxe)</td></tr>
<tr class="memdesc:a4f70b1020467a972266d68b8c3ead0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">report (to user) that an RX operation has completed  <a href="#a4f70b1020467a972266d68b8c3ead0df">More...</a><br/></td></tr>
<tr class="separator:a4f70b1020467a972266d68b8c3ead0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b52291a1ab70d4acc41c9247c5f8d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a49b52291a1ab70d4acc41c9247c5f8d8">efa_rdm_ope_handle_recv_completed</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope)</td></tr>
<tr class="memdesc:a49b52291a1ab70d4acc41c9247c5f8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the event "all data has been received" for an ope  <a href="#a49b52291a1ab70d4acc41c9247c5f8d8">More...</a><br/></td></tr>
<tr class="separator:a49b52291a1ab70d4acc41c9247c5f8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c26e2178e3add69d61a2575e355831"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a74c26e2178e3add69d61a2575e355831">efa_rdm_ope_handle_send_completed</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope)</td></tr>
<tr class="memdesc:a74c26e2178e3add69d61a2575e355831"><td class="mdescLeft">&#160;</td><td class="mdescRight">handle the event that an ope has "sent all the data".  <a href="#a74c26e2178e3add69d61a2575e355831">More...</a><br/></td></tr>
<tr class="separator:a74c26e2178e3add69d61a2575e355831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ef18467c25d81e14efef1740ad1d7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a84ef18467c25d81e14efef1740ad1d7e">efa_rdm_ope_prepare_to_post_read</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope)</td></tr>
<tr class="memdesc:a84ef18467c25d81e14efef1740ad1d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepare an ope such that it is ready to post read request(s)  <a href="#a84ef18467c25d81e14efef1740ad1d7e">More...</a><br/></td></tr>
<tr class="separator:a84ef18467c25d81e14efef1740ad1d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcf91a07558e0844ff48cfe9686202c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a5dcf91a07558e0844ff48cfe9686202c">efa_rdm_ope_prepare_to_post_write</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope)</td></tr>
<tr class="memdesc:a5dcf91a07558e0844ff48cfe9686202c"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepare an ope such that it is ready to post write request(s)  <a href="#a5dcf91a07558e0844ff48cfe9686202c">More...</a><br/></td></tr>
<tr class="separator:a5dcf91a07558e0844ff48cfe9686202c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5488eebd7da1fe58bd0c096e485ac7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a2d5488eebd7da1fe58bd0c096e485ac7">efa_rdm_ope_post_read</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope)</td></tr>
<tr class="memdesc:a2d5488eebd7da1fe58bd0c096e485ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">post read request(s)  <a href="#a2d5488eebd7da1fe58bd0c096e485ac7">More...</a><br/></td></tr>
<tr class="separator:a2d5488eebd7da1fe58bd0c096e485ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8448d18997ada8c6c413c41a110e019b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a8448d18997ada8c6c413c41a110e019b">efa_rdm_ope_post_remote_write</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope)</td></tr>
<tr class="memdesc:a8448d18997ada8c6c413c41a110e019b"><td class="mdescLeft">&#160;</td><td class="mdescRight">post RDMA write request(s)  <a href="#a8448d18997ada8c6c413c41a110e019b">More...</a><br/></td></tr>
<tr class="separator:a8448d18997ada8c6c413c41a110e019b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec0c443b69cefdf530dbd46a759ce8c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a5ec0c443b69cefdf530dbd46a759ce8c">efa_rdm_ope_post_remote_read_or_queue</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope)</td></tr>
<tr class="separator:a5ec0c443b69cefdf530dbd46a759ce8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d3518af3e47cb2712d14c87c17d41f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a57d3518af3e47cb2712d14c87c17d41f">efa_rdm_rxe_post_local_read_or_queue</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *rxe, size_t rx_data_offset, struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *pke, char *pkt_data, size_t data_size)</td></tr>
<tr class="memdesc:a57d3518af3e47cb2712d14c87c17d41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">post a local read request, queue it if necessary  <a href="#a57d3518af3e47cb2712d14c87c17d41f">More...</a><br/></td></tr>
<tr class="separator:a57d3518af3e47cb2712d14c87c17d41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b4a8d6b11758f8086c3e26e7677039b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a1b4a8d6b11758f8086c3e26e7677039b">efa_rdm_ope_prepare_to_post_send</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope, int pkt_type, int *pke_cnt, int *pke_data_size_vec)</td></tr>
<tr class="memdesc:a1b4a8d6b11758f8086c3e26e7677039b"><td class="mdescLeft">&#160;</td><td class="mdescRight">prepare ope to send the give pkt type  <a href="#a1b4a8d6b11758f8086c3e26e7677039b">More...</a><br/></td></tr>
<tr class="separator:a1b4a8d6b11758f8086c3e26e7677039b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb3828264b4abb9de76c27a28ecca57"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#a2cb3828264b4abb9de76c27a28ecca57">efa_rdm_ope_post_send</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope, int pkt_type)</td></tr>
<tr class="memdesc:a2cb3828264b4abb9de76c27a28ecca57"><td class="mdescLeft">&#160;</td><td class="mdescRight">post packet(s) according to packet type.  <a href="#a2cb3828264b4abb9de76c27a28ecca57">More...</a><br/></td></tr>
<tr class="separator:a2cb3828264b4abb9de76c27a28ecca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7b19acf1e5e86a4bb34a9d348c9577"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="efa__rdm__ope_8h.html#aeb7b19acf1e5e86a4bb34a9d348c9577">efa_rdm_ope_post_send_or_queue</a> (struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *ope, int pkt_type)</td></tr>
<tr class="memdesc:aeb7b19acf1e5e86a4bb34a9d348c9577"><td class="mdescLeft">&#160;</td><td class="mdescRight">post packet(s) according to packet type. Queue the post if -FI_EAGAIN is encountered.  <a href="#aeb7b19acf1e5e86a4bb34a9d348c9577">More...</a><br/></td></tr>
<tr class="separator:aeb7b19acf1e5e86a4bb34a9d348c9577"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a64c8835fcb4546cbdfdc6b073c7e9e00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFA_RDM_IOV_LIMIT&#160;&#160;&#160;(4)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad42060b5cba9e88391dfb6777ba3ce23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFA_RDM_OPE_QUEUED_CTRL&#160;&#160;&#160;BIT_ULL(11)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flag to indicate an ope has queued ctrl packet, </p>
<p>If this flag is on, the op_entyr is on the ope_queued_ctrl_list of the endpoint </p>

</div>
</div>
<a class="anchor" id="a698bbdebcd57b56b76884237ba709696"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFA_RDM_OPE_QUEUED_READ&#160;&#160;&#160;BIT_ULL(12)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flag to indicate an ope has queued read requests </p>
<p>When this flag is on, the ope is on ope_queued_read_list of the endpoint </p>

</div>
</div>
<a class="anchor" id="a9c0dec9475fb43f471d8d69ca67d4f68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFA_RDM_OPE_QUEUED_RNR&#160;&#160;&#160;BIT_ULL(9)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flag to tell if an ope encouter RNR when sending packets </p>
<p>If an ope has this flag, it is on the ope_queued_rnr_list of the endpoint. </p>

</div>
</div>
<a class="anchor" id="a4754c8ac80dd5c45094e5d610288f930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFA_RDM_RXE_EOR_IN_FLIGHT&#160;&#160;&#160;BIT_ULL(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag to indicate an rxe has an EOR in flight. </p>
<p>In flag means the EOR has been sent or queued, and has not got send completion. hence the rxe cannot be released </p>

</div>
</div>
<a class="anchor" id="a0de598edaa9e8efe2998a538dcc8b86e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFA_RDM_RXE_RECV_CANCEL&#160;&#160;&#160;BIT_ULL(3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>indicate an ope's receive has been cancel </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>: In future we will send RECV_CANCEL signal to sender, to stop transmitting large message, this flag is also used for fi_discard which has similar behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="a18cabd432fbc4a16bb4a2386236c4293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFA_RDM_TXE_DELIVERY_COMPLETE_REQUESTED&#160;&#160;&#160;BIT_ULL(6)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag to tell if the transmission is using FI_DELIVERY_COMPLETE protocols. </p>

</div>
</div>
<a class="anchor" id="ab8c1d29f95da6003c0cc87312d20f9f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFA_RDM_TXE_NO_COMPLETION&#160;&#160;&#160;BIT_ULL(60)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flag to indicate an ope does not need to report completion to user </p>
<p>This flag is used to by emulated injection and <a class="el" href="efa__rdm__ep__utils_8c.html#a5c25545ecf59a398eff366a7c420682e" title="trigger a peer to send a handshake packet ">efa_rdm_ep_trigger_handshake</a> </p>

</div>
</div>
<a class="anchor" id="a2dc4677513b3d906707808b8ba538c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFA_RDM_TXE_NO_COUNTER&#160;&#160;&#160;BIT_ULL(61)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flag to indicate an ope does not need to increase counter </p>
<p>This flag is used to implement <a class="el" href="efa__rdm__ep__utils_8c.html#a5c25545ecf59a398eff366a7c420682e" title="trigger a peer to send a handshake packet ">efa_rdm_ep_trigger_handshake</a> </p>

</div>
</div>
<a class="anchor" id="a9093708d84fbe511f92aa95aedaf2f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFA_RDM_TXE_WRITTEN_RNR_CQ_ERR_ENTRY&#160;&#160;&#160;BIT_ULL(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>flag to indicate a txe has already written an cq error entry for RNR </p>
<p>This flag is used to prevent writing multiple cq error entries for the same txe </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="acfa7c40e76455a0248fb496a26d9583b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="efa__rdm__ope_8h.html#acfa7c40e76455a0248fb496a26d9583b">efa_rdm_cuda_copy_method</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>how to copy data from bounce buffer to CUDA receive buffer </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="acfa7c40e76455a0248fb496a26d9583ba573464aa8f589eab378cf87a879a0115"></a>EFA_RDM_CUDA_COPY_UNSPEC</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acfa7c40e76455a0248fb496a26d9583ba49b4d615ffb2b73de7cd5417984faa28"></a>EFA_RDM_CUDA_COPY_BLOCKING</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acfa7c40e76455a0248fb496a26d9583ba6aae189b87b22b4c1d5391d651018448"></a>EFA_RDM_CUDA_COPY_LOCALREAD</em>&nbsp;</td><td class="fielddoc">
<p>gdrcopy or cudaMemcpy device driven copy by using local RDMA read </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a6c9901821c399c33346c2a539e688a30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="efa__rdm__ope_8h.html#a6c9901821c399c33346c2a539e688a30">efa_rdm_ope_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EFA RDM operation entry (ope)'s state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a6c9901821c399c33346c2a539e688a30a4df26b738b43152b2eae14bdadaa08d8"></a>EFA_RDM_OPE_FREE</em>&nbsp;</td><td class="fielddoc">
<p>txe/rxe free state </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6c9901821c399c33346c2a539e688a30a6edc952c1fffee5962bb6360d9c13846"></a>EFA_RDM_TXE_REQ</em>&nbsp;</td><td class="fielddoc">
<p>txe sending REQ packet </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6c9901821c399c33346c2a539e688a30a4c6f11bd54a0d7f75fb8c08f758d2c48"></a>EFA_RDM_TXE_SEND</em>&nbsp;</td><td class="fielddoc">
<p>txe sending data in progress </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6c9901821c399c33346c2a539e688a30a0709e08ce9b65224aa3da2d60a489989"></a>EFA_RDM_RXE_INIT</em>&nbsp;</td><td class="fielddoc">
<p>rxe ready to recv RTM </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6c9901821c399c33346c2a539e688a30a6351d6db7d4eb41e6f52172fb95c182a"></a>EFA_RDM_RXE_UNEXP</em>&nbsp;</td><td class="fielddoc">
<p>rxe unexp msg waiting for post recv </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6c9901821c399c33346c2a539e688a30a1754f19e6e9fcd2cfe7f9b74fb6eb61e"></a>EFA_RDM_RXE_MATCHED</em>&nbsp;</td><td class="fielddoc">
<p>rxe matched with RTM </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a6c9901821c399c33346c2a539e688a30a804793464095cfae2c76d05989523d75"></a>EFA_RDM_RXE_RECV</em>&nbsp;</td><td class="fielddoc">
<p>rxe large msg recv data pkts </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a3560fc43be30d9394c75582ad73c1e4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="efa__rdm__ope_8h.html#a3560fc43be30d9394c75582ad73c1e4e">efa_rdm_ope_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EFA RDM operation entry (ope) type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a3560fc43be30d9394c75582ad73c1e4ea504f600f59c06030e4fc9be918617c91"></a>EFA_RDM_TXE</em>&nbsp;</td><td class="fielddoc">
<p>this ope is for an TX operation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a3560fc43be30d9394c75582ad73c1e4ea283ee9d48b376f2ba4dddbc88001b198"></a>EFA_RDM_RXE</em>&nbsp;</td><td class="fielddoc">
<p>this ope is for an RX operation </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a49b52291a1ab70d4acc41c9247c5f8d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_ope_handle_recv_completed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>handle the event "all data has been received" for an ope </p>
<p>Both txe and rxe can receive data.</p>
<p>txe can receive data when the operation is read and emulated read is used.</p>
<p>rxe can receiver data when the operation is receive or write response.</p>
<p>To complete a RX operation, this function does 3 things:</p>
<ol type="1">
<li>If necessary, write completion to application. (Not all completed RX action will cause a completion to be written).</li>
<li>If delievery complete is requested send a receipt packet back to the peer.</li>
<li>Release the ope unless the ope is rxe, and an RECEIPT/EOR packet has been sent. This is because rxe is needed to handle the send completion event of RECEIPT/EOR</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ope</td><td>ope that contains information of a data receive operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74c26e2178e3add69d61a2575e355831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_ope_handle_send_completed </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>handle the event that an ope has "sent all the data". </p>
<p>Note that both txe and rxe can send data:</p>
<p>txe will send data when operation type is send/write. In this case, the exact timing of "all the data has been sent" event is: </p>
<pre class="fragment">If the txe requested delivery complete, "all the data has been sent"
 happens when txe received a RECEIPT packet from receiver/write responder

If the txe requested delivery complete, "all the data has been sent"
 happens when the send completion of all packets that contains data has been
 received.
</pre><p>rxe will send data when operation type is read and emulated read is used. In this case, "all data has been sent" happens when txe received the completion of all the packets that contains data.</p>
<p>In both cases, the "all data has been send" event mark the end of the operation, therefore this function will call efa_rdm_txe/ope_report_completion(), and release the ope</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ope</td><td>inforatminon of op entry that sends data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae70fc78d870cb49a86d4207b83db307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t efa_rdm_ope_mulreq_total_data_size </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pkt_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>total data size that will be sent/received via the multiple REQ packets </p>
<p>Multi-req protocols send/receive data via multiple REQ packets. Different protocols have different behavior: </p>
<pre class="fragment">Medium protocols send/receive all data via REQ packets

Runting read protocols send/receive part of the data via REQ packets.
The reminder of the data is sent via other type of packets or via RDMA operations.
</pre><p>which is why this function is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ope</td><td>contains operation information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_type</td><td>REQ packet type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of total data transfered by REQ packets </dd></dl>

</div>
</div>
<a class="anchor" id="a2d5488eebd7da1fe58bd0c096e485ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int efa_rdm_ope_post_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>post read request(s) </p>
<p>This function posts read request(s) according to information in ope. Depend on ope-&gt;bytes_read_total_len and max read size of device. This function might issue multiple read requdsts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ope</td><td>ope that has information of the read request. If read request is successfully submitted, ope-&gt;bytes_read_submitted will be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, return 0 On failure, return a negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ec0c443b69cefdf530dbd46a759ce8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int efa_rdm_ope_post_remote_read_or_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8448d18997ada8c6c413c41a110e019b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int efa_rdm_ope_post_remote_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>post RDMA write request(s) </p>
<p>This function posts write request(s) according to information in ope. Depending on ope-&gt;bytes_write_total_len and max write size of device, this function might issue multiple write requests.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ope</td><td>ope that has information of the read request. If write request is successfully submitted, ope-&gt;bytes_write_submitted will be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, return 0 On failure, return a negative error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cb3828264b4abb9de76c27a28ecca57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t efa_rdm_ope_post_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pkt_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>post packet(s) according to packet type. </p>
<p>Depend on packet type, this function may post one packet or multiple packets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ope</td><td>pointer to <a class="el" href="structefa__rdm__ope.html" title="EFA RDM operation entry (ope) ">efa_rdm_ope</a>. (either a txe or an rxe) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_type</td><td>packet type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success return 0, otherwise return a negative libfabric error code. Possible error codes include: -FI_EAGAIN temporarily out of resource </dd></dl>

</div>
</div>
<a class="anchor" id="aeb7b19acf1e5e86a4bb34a9d348c9577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t efa_rdm_ope_post_send_or_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pkt_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>post packet(s) according to packet type. Queue the post if -FI_EAGAIN is encountered. </p>
<p>This function will call <a class="el" href="efa__rdm__ope_8c.html#a2cb3828264b4abb9de76c27a28ecca57" title="post packet(s) according to packet type. ">efa_rdm_ope_post_send()</a> to post packet(s) according to packet type. If <a class="el" href="efa__rdm__ope_8c.html#a2cb3828264b4abb9de76c27a28ecca57" title="post packet(s) according to packet type. ">efa_rdm_ope_post_send()</a> returned -FI_EAGAIN, this function will put the txe in <a class="el" href="structefa__rdm__ep.html">efa_rdm_ep</a>'s queued_ctrl_list. The progress engine will try to post the packet later.</p>
<p>This function is mainly used by packet handler to post responsive ctrl packet (such as EOR and CTS).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ope</td><td>pointer to <a class="el" href="structefa__rdm__ope.html" title="EFA RDM operation entry (ope) ">efa_rdm_ope</a>. (either a txe or an rxe) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_type</td><td>packet type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success return 0, otherwise return a negative libfabric error code. </dd></dl>

</div>
</div>
<a class="anchor" id="a84ef18467c25d81e14efef1740ad1d7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int efa_rdm_ope_prepare_to_post_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prepare an ope such that it is ready to post read request(s) </p>
<p>An ope can post read request(s) for two reasons:</p>
<p>First, it can be because user directly initiated a read requst (by calling fi_readxxx() API). In this case the ope argument will be a txe (ope-&gt;type == EFA_RDM_TXE)</p>
<p>Second, it can be part of a read-base message protocol, such as the longread message protocol. In this case, the ope argument will be a rxe (ope-&gt;type == EFA_RDM_RXE)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ep</td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ope</td><td>information of the operation the needs to post a read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the read request is posted successfully. negative libfabric error code on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b4a8d6b11758f8086c3e26e7677039b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t efa_rdm_ope_prepare_to_post_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pkt_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pke_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pke_data_size_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prepare ope to send the give pkt type </p>
<p>For given packet type, calcuate how many packets are going to be sent. If there are more than 1 packet, calculate how many data each packet will carry.</p>
<p>For runting read rtm, also set the "runt_size" field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ope</td><td>txe that has all information of a send operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_type</td><td>type of REQ packet </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pke_cnt</td><td>number of packets to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pke_data_size_vec</td><td>data size of each packet. This field is used when pke_cnt &gt; 1. (for DATA, MEDIUM and RUNTREAD) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, return 0 If there is not enough available packet entry in TX packet pool, return -FI_EAGAIN </dd></dl>

</div>
</div>
<a class="anchor" id="a5dcf91a07558e0844ff48cfe9686202c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_ope_prepare_to_post_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prepare an ope such that it is ready to post write request(s) </p>
<p>An ope will post write request(s) after a user directly initiated a write request (by calling fi_writexxx() API). The ope-&gt;type will be EFA_RDM_TXE</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ep</td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ope</td><td>information the operation needs to post a write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20ee83f8ce8dcf17f32aeed13cc01614"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_ope_try_fill_desc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>ope</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mr_iov_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>try to fill the desc field of an ope by memory registration </p>
<p>The desc field of ope contains the memory descriptors of the user's data buffer.</p>
<p>For EFA provider, a data buffer's memory descriptor is a pointer to an <a class="el" href="structefa__mr.html">efa_mr</a> object, which contains the memory registration information of the data buffer.</p>
<p>EFA provider does not require user to provide a descriptor when user's data buffer is on host memory (Though user can register its buffer, and provide its descriptor as an optimization).</p>
<p>However, there are a few occations that EFA device require memory to be register with them:</p>
<p>When EFA device is used to send data:</p>
<p>If a non-read based protocol (such as eager, meidum, longcts) is used, the send buffer must be registered with EFA device.</p>
<p>If a read based protocol is used, both send buffer and receive buffer must be registered with EFA device.</p>
<p>Therefore, when user did not provide descriptors for the buffer(s), EFA provider need to bridge the gap.</p>
<p>On sender side:</p>
<p>First, EFA provider can copy the user data to a pre-registered bounce buffer, then send data from bounce buffer. (this happens when EFA device is used, and eager protocol is used)</p>
<p>Second, EFA provider can register the user's buffer and fill desc (by calling this function). then send directly from send buffer. Because of the high cost of memory registration, this happens only when MR cache is available, which is checked by the caller of this function on sender side. (this happens when EFA device is used with non-eager protocols and</p>
<p>This function is not guaranteed to fill all descriptors (which is why the function name has try). When memory registration fail due to limited resources, EFA provider may either fallback to to use bounce buffer, or return -FI_EAGAIN to user and let user run progress engine, which will release memory from MR cache.</p>
<p>On receiver side:</p>
<p>The only occasion receiver buffer need to be registered is when EFA device is used with a read base message protocol, in which case this function is called for the registration.</p>
<p>If the function did not fill desc due to temporarily out of resource. EFA provider need to run progress engine to release memory registration then retry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ope</td><td>contains the inforation of a TX/RX operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mr_iov_start</td><td>the IOV index to start generating descriptors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">access</td><td>the access flag for the memory registation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7deb054533b43c65d81e077df3a0a05a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_rxe_handle_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>rxe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prov_errno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>handle the situation that an error has happened to an RX (receive) operation </p>
<p>This function does the following to handle error:</p>
<ol type="1">
<li>write an error cq entry to notify application the rx operation failed. If write failed, it will write an eq entry.</li>
<li>increase error counter.</li>
<li>print warning message about the error with self and peer's raw address.</li>
<li>release resources owned by the rxe, such as unexpected packet entry, because the RX operation is aborted.</li>
<li>remove the rxe from queued rxe list for the same reason.</li>
</ol>
<p>Note, It will NOT release the rxe because it is still possible to receive packet for this rxe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rxe</td><td>rxe encountered error </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>positive libfabric error code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prov_errno</td><td>positive provider specific error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57d3518af3e47cb2712d14c87c17d41f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int efa_rdm_rxe_post_local_read_or_queue </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>rxe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rx_data_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__pke.html">efa_rdm_pke</a> *&#160;</td>
          <td class="paramname"><em>pke</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pkt_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>post a local read request, queue it if necessary </p>
<p>a local read request is posted to copy data from a packet entry to user posted receive buffer on device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rxe</td><td>which has the receive buffer information </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rx_data_offset</td><td>offset of data in the receive buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pke</td><td>which has the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_data</td><td>pointer to the data in the packet entry </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>size of the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, negative error code on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aa49897eb45f4740c247a8dea7acd0525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_rxe_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>rxe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa45c8089fbd0d68575a04896129a5702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_rxe_release_internal </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>rxe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the efa specific resources in efa_rdm_rxe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxe</td><td><a class="el" href="structefa__rdm__ope.html" title="EFA RDM operation entry (ope) ">efa_rdm_ope</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f70b1020467a972266d68b8c3ead0df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_rxe_report_completion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>rxe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>report (to user) that an RX operation has completed </p>
<p>An RX operation can be recevie, write response, read response and atomic response. This function will do the following:</p>
<ol type="1">
<li>write an CQ entry. If the message is truncated, (receiving buffer is too small to hold incming message), the CQ entry will be an error CQ entry, otherwise the CQ entry will be normal CQ entry. User will get the CQ entry will it call fi_cq_read()</li>
<li>increase counter. User will get the updated counter when it call fi_cntr_read()</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rxe</td><td>information of the completed RX operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0332d3ff554093510a6436960603237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_txe_construct </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>txe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ep.html">efa_rdm_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct fi_msg *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa5c6d10e4eff9aca604509f7c40ead4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_txe_handle_error </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>txe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prov_errno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>handle the situation that a TX operation encountered error </p>
<p>This function does the follow to handle error:</p>
<ol type="1">
<li>write an error cq entry for the TX operation, if writing CQ error entry failed, it will write eq entry.</li>
<li>increase error counter.</li>
<li>remove the txe from ep-&gt;tx_queued_list and ep-&gt;tx_pending_list if the txe is on it.</li>
<li>print warning message with self and peer's raw address</li>
</ol>
<p>Note It does NOT release txe because it is still possible to receive send completion for this txe</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">txe</td><td>txe that encountered error </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>positive libfabric error code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prov_errno</td><td>positive EFA provider specific error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae642be6908c005bfa49847c841df60b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t efa_rdm_txe_max_req_data_capacity </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ep.html">efa_rdm_ep</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>txe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pkt_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the maximum data capacity of a REQ packet for an send operation </p>
<p>The REQ packet header length is a variable that depends on a number of factors, including:</p>
<p>packet_type, peer_type, cq_data and number of rma iov.</p>
<p>As a result the maximum data capacity of a REQ packet for a send operation,( which is the number of bytes of data can be saved in a REQ packet) is different.</p>
<p>This function is used to caculate the maxium data capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>endpoint </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">txe</td><td>txe that has all information of a send operation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pkt_type</td><td>type of REQ packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maxiumum number of bytes of data can be save in a REQ packet for given send operation and REQ packet type. </dd></dl>

</div>
</div>
<a class="anchor" id="afec7f1fe0929a0e9126384b9a2a66e38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int efa_rdm_txe_prepare_to_be_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>txe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct fi_rma_iov *&#160;</td>
          <td class="paramname"><em>read_iov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2ad8d0b1851916f68fa90360cdac2b49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_txe_release </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>txe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aac2a2c841aa88840057302b4415582b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void efa_rdm_txe_report_completion </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structefa__rdm__ope.html">efa_rdm_ope</a> *&#160;</td>
          <td class="paramname"><em>txe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>report (to user) that a TX operation has completed </p>
<p>This function does the following to report completion:</p>
<ol type="1">
<li>write a cq entry for the TX operation when necessary Sometimes it is not necessary to to write CQ entry See #efa_rdm_ope_should_update_cq</li>
<li>update counter if necessary.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">txe</td><td>information of the completed TX operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
